{"version":3,"sources":["webpack:///../website/addons/forward/static/node-cfg.js","webpack:///../~/knockout.punches/index.js?2063*********","webpack:///../website/addons/forward/static/forwardConfig.js"],"names":[],"mappings":";;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa,gCAAgC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY,EAAE;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD,EAAE,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,mCAAmC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,OAAO;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,KAAK;AACL;AACA,KAAK,0BAA0B,oBAAoB;AACnD;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,6FAA6F,OAAO;AACpG;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACrkBA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA","file":"forward/node-cfg.js","sourcesContent":["var ForwardConfig = require('./forwardConfig.js');\n\nvar url = window.contextVars.node.urls.api + 'forward/config/';\n// #forwardScope will only be in the DOM if the addon is properly configured\nif ($('#forwardScope')[0]) {\n    new ForwardConfig('#forwardScope', url, window.contextVars.node.id);\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../website/addons/forward/static/node-cfg.js\n ** module id = 0\n ** module chunks = 17\n **/","/**\n * @license Knockout.Punches\n * Enhanced binding syntaxes for Knockout 3+\n * (c) Michael Best\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n * Version 0.5.1\n */\nvar ko = require('knockout');\n\n// Add a preprocess function to a binding handler.\nfunction addBindingPreprocessor(bindingKeyOrHandler, preprocessFn) {\n    return chainPreprocessor(getOrCreateHandler(bindingKeyOrHandler), 'preprocess', preprocessFn);\n}\n\n// These utility functions are separated out because they're also used by\n// preprocessBindingProperty\n\n// Get the binding handler or create a new, empty one\nfunction getOrCreateHandler(bindingKeyOrHandler) {\n    return typeof bindingKeyOrHandler === 'object' ? bindingKeyOrHandler :\n        (ko.getBindingHandler(bindingKeyOrHandler) || (ko.bindingHandlers[bindingKeyOrHandler] = {}));\n}\n// Add a preprocess function\nfunction chainPreprocessor(obj, prop, fn) {\n    if (obj[prop]) {\n        // If the handler already has a preprocess function, chain the new\n        // one after the existing one. If the previous function in the chain\n        // returns a falsy value (to remove the binding), the chain ends. This\n        // method allows each function to modify and return the binding value.\n        var previousFn = obj[prop];\n        obj[prop] = function(value, binding, addBinding) {\n            value = previousFn.call(this, value, binding, addBinding);\n            if (value)\n                return fn.call(this, value, binding, addBinding);\n        };\n    } else {\n        obj[prop] = fn;\n    }\n    return obj;\n}\n\n// Add a preprocessNode function to the binding provider. If a\n// function already exists, chain the new one after it. This calls\n// each function in the chain until one modifies the node. This\n// method allows only one function to modify the node.\nfunction addNodePreprocessor(preprocessFn) {\n    var provider = ko.bindingProvider.instance;\n    if (provider.preprocessNode) {\n        var previousPreprocessFn = provider.preprocessNode;\n        provider.preprocessNode = function(node) {\n            var newNodes = previousPreprocessFn.call(this, node);\n            if (!newNodes)\n                newNodes = preprocessFn.call(this, node);\n            return newNodes;\n        };\n    } else {\n        provider.preprocessNode = preprocessFn;\n    }\n}\n\nfunction addBindingHandlerCreator(matchRegex, callbackFn) {\n    var oldGetHandler = ko.getBindingHandler;\n    ko.getBindingHandler = function(bindingKey) {\n        var match;\n        return oldGetHandler(bindingKey) || ((match = bindingKey.match(matchRegex)) && callbackFn(match, bindingKey));\n    };\n}\n\n// Create shortcuts to commonly used ko functions\nvar ko_unwrap = ko.unwrap;\n\n// Create \"punches\" object and export utility functions\nvar ko_punches = ko.punches = {\n    utils: {\n        addBindingPreprocessor: addBindingPreprocessor,\n        addNodePreprocessor: addNodePreprocessor,\n        addBindingHandlerCreator: addBindingHandlerCreator,\n\n        // previous names retained for backwards compitibility\n        setBindingPreprocessor: addBindingPreprocessor,\n        setNodePreprocessor: addNodePreprocessor\n    }\n};\n\nko_punches.enableAll = function () {\n    // Enable interpolation markup\n    enableInterpolationMarkup();\n    enableAttributeInterpolationMarkup();\n\n    // Enable auto-namspacing of attr, css, event, and style\n    enableAutoNamespacedSyntax('attr');\n    enableAutoNamespacedSyntax('css');\n    enableAutoNamespacedSyntax('event');\n    enableAutoNamespacedSyntax('style');\n\n    // Make sure that Knockout knows to bind checked after attr.value (see #40)\n    ko.bindingHandlers.checked.after.push('attr.value');\n\n    // Enable filter syntax for text, html, and attr\n    enableTextFilter('text');\n    enableTextFilter('html');\n    addDefaultNamespacedBindingPreprocessor('attr', filterPreprocessor);\n\n    // Enable wrapped callbacks for click, submit, event, optionsAfterRender, and template options\n    enableWrappedCallback('click');\n    enableWrappedCallback('submit');\n    enableWrappedCallback('optionsAfterRender');\n    addDefaultNamespacedBindingPreprocessor('event', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'beforeRemove', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'afterAdd', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'afterRender', wrappedCallbackPreprocessor);\n};\n// Convert input in the form of `expression | filter1 | filter2:arg1:arg2` to a function call format\n// with filters accessed as ko.filters.filter1, etc.\nfunction filterPreprocessor(input) {\n    // Check if the input contains any | characters; if not, just return\n    if (input.indexOf('|') === -1)\n        return input;\n\n    // Split the input into tokens, in which | and : are individual tokens, quoted strings are ignored, and all tokens are space-trimmed\n    var tokens = input.match(/\"([^\"\\\\]|\\\\.)*\"|'([^'\\\\]|\\\\.)*'|\\|\\||[|:]|[^\\s|:\"'][^|:\"']*[^\\s|:\"']|[^\\s|:\"']/g);\n    if (tokens && tokens.length > 1) {\n        // Append a line so that we don't need a separate code block to deal with the last item\n        tokens.push('|');\n        input = tokens[0];\n        var lastToken, token, inFilters = false, nextIsFilter = false;\n        for (var i = 1, token; token = tokens[i]; ++i) {\n            if (token === '|') {\n                if (inFilters) {\n                    if (lastToken === ':')\n                        input += \"undefined\";\n                    input += ')';\n                }\n                nextIsFilter = true;\n                inFilters = true;\n            } else {\n                if (nextIsFilter) {\n                    input = \"ko.filters['\" + token + \"'](\" + input;\n                } else if (inFilters && token === ':') {\n                    if (lastToken === ':')\n                        input += \"undefined\";\n                    input += \",\";\n                } else {\n                    input += token;\n                }\n                nextIsFilter = false;\n            }\n            lastToken = token;\n        }\n    }\n    return input;\n}\n\n// Set the filter preprocessor for a specific binding\nfunction enableTextFilter(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, filterPreprocessor);\n}\n\nvar filters = {};\n\n// Convert value to uppercase\nfilters.uppercase = function(value) {\n    return String.prototype.toUpperCase.call(ko_unwrap(value));\n};\n\n// Convert value to lowercase\nfilters.lowercase = function(value) {\n    return String.prototype.toLowerCase.call(ko_unwrap(value));\n};\n\n// Return default value if the input value is empty or null\nfilters['default'] = function (value, defaultValue) {\n    value = ko_unwrap(value);\n    if (typeof value === \"function\") {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        return trim(value) === '' ? defaultValue : value;\n    }\n    return value == null || value.length == 0 ? defaultValue : value;\n};\n\n// Return the value with the search string replaced with the replacement string\nfilters.replace = function(value, search, replace) {\n    return String.prototype.replace.call(ko_unwrap(value), search, replace);\n};\n\nfilters.fit = function(value, length, replacement, trimWhere) {\n    value = ko_unwrap(value);\n    if (length && ('' + value).length > length) {\n        replacement = '' + (replacement || '...');\n        length = length - replacement.length;\n        value = '' + value;\n        switch (trimWhere) {\n            case 'left':\n                return replacement + value.slice(-length);\n            case 'middle':\n                var leftLen = Math.ceil(length / 2);\n                return value.substr(0, leftLen) + replacement + value.slice(leftLen-length);\n            default:\n                return value.substr(0, length) + replacement;\n        }\n    } else {\n        return value;\n    }\n};\n\n// Convert a model object to JSON\nfilters.json = function(rootObject, space, replacer) {     // replacer and space are optional\n    return ko.toJSON(rootObject, replacer, space);\n};\n\n// Format a number using the browser's toLocaleString\nfilters.number = function(value) {\n    return (+ko_unwrap(value)).toLocaleString();\n};\n\n// Export the filters object for general access\nko.filters = filters;\n\n// Export the preprocessor functions\nko_punches.textFilter = {\n    preprocessor: filterPreprocessor,\n    enableForBinding: enableTextFilter\n};\n// Support dynamically-created, namespaced bindings. The binding key syntax is\n// \"namespace.binding\". Within a certain namespace, we can dynamically create the\n// handler for any binding. This is particularly useful for bindings that work\n// the same way, but just set a different named value, such as for element\n// attributes or CSS classes.\nvar namespacedBindingMatch = /([^\\.]+)\\.(.+)/, namespaceDivider = '.';\naddBindingHandlerCreator(namespacedBindingMatch, function (match, bindingKey) {\n    var namespace = match[1],\n        namespaceHandler = ko.bindingHandlers[namespace];\n    if (namespaceHandler) {\n        var bindingName = match[2],\n            handlerFn = namespaceHandler.getNamespacedHandler || defaultGetNamespacedHandler,\n            handler = handlerFn.call(namespaceHandler, bindingName, namespace, bindingKey);\n        ko.bindingHandlers[bindingKey] = handler;\n        return handler;\n    }\n});\n\n// Knockout's built-in bindings \"attr\", \"event\", \"css\" and \"style\" include the idea of\n// namespaces, representing it using a single binding that takes an object map of names\n// to values. This default handler translates a binding of \"namespacedName: value\"\n// to \"namespace: {name: value}\" to automatically support those built-in bindings.\nfunction defaultGetNamespacedHandler(name, namespace, namespacedName) {\n    var handler = ko.utils.extend({}, this);\n    function setHandlerFunction(funcName) {\n        if (handler[funcName]) {\n            handler[funcName] = function(element, valueAccessor) {\n                function subValueAccessor() {\n                    var result = {};\n                    result[name] = valueAccessor();\n                    return result;\n                }\n                var args = Array.prototype.slice.call(arguments, 0);\n                args[1] = subValueAccessor;\n                return ko.bindingHandlers[namespace][funcName].apply(this, args);\n            };\n        }\n    }\n    // Set new init and update functions that wrap the originals\n    setHandlerFunction('init');\n    setHandlerFunction('update');\n    // Clear any preprocess function since preprocessing of the new binding would need to be different\n    if (handler.preprocess)\n        handler.preprocess = null;\n    if (ko.virtualElements.allowedBindings[namespace])\n        ko.virtualElements.allowedBindings[namespacedName] = true;\n    return handler;\n}\n\n// Adds a preprocess function for every generated namespace.x binding. This can\n// be called multiple times for the same binding, and the preprocess functions will\n// be chained. If the binding has a custom getNamespacedHandler method, make sure that\n// it's set before this function is used.\nfunction addDefaultNamespacedBindingPreprocessor(namespace, preprocessFn) {\n    var handler = ko.getBindingHandler(namespace);\n    if (handler) {\n        var previousHandlerFn = handler.getNamespacedHandler || defaultGetNamespacedHandler;\n        handler.getNamespacedHandler = function() {\n            return addBindingPreprocessor(previousHandlerFn.apply(this, arguments), preprocessFn);\n        };\n    }\n}\n\nfunction autoNamespacedPreprocessor(value, binding, addBinding) {\n    if (value.charAt(0) !== \"{\")\n        return value;\n\n    // Handle two-level binding specified as \"binding: {key: value}\" by parsing inner\n    // object and converting to \"binding.key: value\"\n    var subBindings = ko.expressionRewriting.parseObjectLiteral(value);\n    ko.utils.arrayForEach(subBindings, function(keyValue) {\n        addBinding(binding + namespaceDivider + keyValue.key, keyValue.value);\n    });\n}\n\n// Set the namespaced preprocessor for a specific binding\nfunction enableAutoNamespacedSyntax(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, autoNamespacedPreprocessor);\n}\n\n// Export the preprocessor functions\nko_punches.namespacedBinding = {\n    defaultGetHandler: defaultGetNamespacedHandler,\n    setDefaultBindingPreprocessor: addDefaultNamespacedBindingPreprocessor,    // for backwards compat.\n    addDefaultBindingPreprocessor: addDefaultNamespacedBindingPreprocessor,\n    preprocessor: autoNamespacedPreprocessor,\n    enableForBinding: enableAutoNamespacedSyntax\n};\n// Wrap a callback function in an anonymous function so that it is called with the appropriate\n// \"this\" value.\nfunction wrappedCallbackPreprocessor(val) {\n    // Matches either an isolated identifier or something ending with a property accessor\n    if (/^([$_a-z][$\\w]*|.+(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i.test(val)) {\n        return 'function(_x,_y,_z){return(' + val + ')(_x,_y,_z);}';\n    } else {\n        return val;\n    }\n}\n\n// Set the wrappedCallback preprocessor for a specific binding\nfunction enableWrappedCallback(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, wrappedCallbackPreprocessor);\n}\n\n// Export the preprocessor functions\nko_punches.wrappedCallback = {\n    preprocessor: wrappedCallbackPreprocessor,\n    enableForBinding: enableWrappedCallback\n};\n// Attach a preprocess function to a specific property of a binding. This allows you to\n// preprocess binding \"options\" using the same preprocess functions that work for bindings.\nfunction addBindingPropertyPreprocessor(bindingKeyOrHandler, property, preprocessFn) {\n    var handler = getOrCreateHandler(bindingKeyOrHandler);\n    if (!handler._propertyPreprocessors) {\n        // Initialize the binding preprocessor\n        chainPreprocessor(handler, 'preprocess', propertyPreprocessor);\n        handler._propertyPreprocessors = {};\n    }\n    // Add the property preprocess function\n    chainPreprocessor(handler._propertyPreprocessors, property, preprocessFn);\n}\n\n// In order to preprocess a binding property, we have to preprocess the binding itself.\n// This preprocess function splits up the binding value and runs each property's preprocess\n// function if it's set.\nfunction propertyPreprocessor(value, binding, addBinding) {\n    if (value.charAt(0) !== \"{\")\n        return value;\n\n    var subBindings = ko.expressionRewriting.parseObjectLiteral(value),\n        resultStrings = [],\n        propertyPreprocessors = this._propertyPreprocessors || {};\n    ko.utils.arrayForEach(subBindings, function(keyValue) {\n        var prop = keyValue.key, propVal = keyValue.value;\n        if (propertyPreprocessors[prop]) {\n            propVal = propertyPreprocessors[prop](propVal, prop, addBinding);\n        }\n        if (propVal) {\n            resultStrings.push(\"'\" + prop + \"':\" + propVal);\n        }\n    });\n    return \"{\" + resultStrings.join(\",\") + \"}\";\n}\n\n// Export the preprocessor functions\nko_punches.preprocessBindingProperty = {\n    setPreprocessor: addBindingPropertyPreprocessor,     // for backwards compat.\n    addPreprocessor: addBindingPropertyPreprocessor\n};\n// Wrap an expression in an anonymous function so that it is called when the event happens\nfunction makeExpressionCallbackPreprocessor(args) {\n    return function expressionCallbackPreprocessor(val) {\n        return 'function('+args+'){return(' + val + ');}';\n    };\n}\n\nvar eventExpressionPreprocessor = makeExpressionCallbackPreprocessor(\"$data,$event\");\n\n// Set the expressionCallback preprocessor for a specific binding\nfunction enableExpressionCallback(bindingKeyOrHandler, args) {\n    var args = Array.prototype.slice.call(arguments, 1).join();\n    addBindingPreprocessor(bindingKeyOrHandler, makeExpressionCallbackPreprocessor(args));\n}\n\n// Export the preprocessor functions\nko_punches.expressionCallback = {\n    makePreprocessor: makeExpressionCallbackPreprocessor,\n    eventPreprocessor: eventExpressionPreprocessor,\n    enableForBinding: enableExpressionCallback\n};\n\n// Create an \"on\" namespace for events to use the expression method\nko.bindingHandlers.on = {\n    getNamespacedHandler: function(eventName) {\n        var handler = ko.getBindingHandler('event' + namespaceDivider + eventName);\n        return addBindingPreprocessor(handler, eventExpressionPreprocessor);\n    }\n};\n// Performance comparison at http://jsperf.com/markup-interpolation-comparison\nfunction parseInterpolationMarkup(textToParse, outerTextCallback, expressionCallback) {\n    function innerParse(text) {\n        var innerMatch = text.match(/^([\\s\\S]*)}}([\\s\\S]*?)\\{\\{([\\s\\S]*)$/);\n        if (innerMatch) {\n            innerParse(innerMatch[1]);\n            outerTextCallback(innerMatch[2]);\n            expressionCallback(innerMatch[3]);\n        } else {\n            expressionCallback(text);\n        }\n    }\n    var outerMatch = textToParse.match(/^([\\s\\S]*?)\\{\\{([\\s\\S]*)}}([\\s\\S]*)$/);\n    if (outerMatch) {\n        outerTextCallback(outerMatch[1]);\n        innerParse(outerMatch[2]);\n        outerTextCallback(outerMatch[3]);\n    }\n}\n\nfunction trim(string) {\n    return string == null ? '' :\n        string.trim ?\n            string.trim() :\n            string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n}\n\nfunction interpolationMarkupPreprocessor(node) {\n    // only needs to work with text nodes\n    if (node.nodeType === 3 && node.nodeValue && node.nodeValue.indexOf('{{') !== -1 && (node.parentNode || {}).nodeName != \"TEXTAREA\") {\n        var nodes = [];\n        function addTextNode(text) {\n            if (text)\n                nodes.push(document.createTextNode(text));\n        }\n        function wrapExpr(expressionText) {\n            if (expressionText)\n                nodes.push.apply(nodes, ko_punches_interpolationMarkup.wrapExpression(expressionText, node));\n        }\n        parseInterpolationMarkup(node.nodeValue, addTextNode, wrapExpr)\n\n        if (nodes.length) {\n            if (node.parentNode) {\n                for (var i = 0, n = nodes.length, parent = node.parentNode; i < n; ++i) {\n                    parent.insertBefore(nodes[i], node);\n                }\n                parent.removeChild(node);\n            }\n            return nodes;\n        }\n    }\n}\n\nif (!ko.virtualElements.allowedBindings.html) {\n    // Virtual html binding\n    // SO Question: http://stackoverflow.com/a/15348139\n    var overridden = ko.bindingHandlers.html.update;\n    ko.bindingHandlers.html.update = function (element, valueAccessor) {\n        if (element.nodeType === 8) {\n            var html = ko_unwrap(valueAccessor());\n            if (html != null) {\n                var parsedNodes = ko.utils.parseHtmlFragment('' + html);\n                ko.virtualElements.setDomNodeChildren(element, parsedNodes);\n            } else {\n                ko.virtualElements.emptyNode(element);\n            }\n        } else {\n            overridden(element, valueAccessor);\n        }\n    };\n    ko.virtualElements.allowedBindings.html = true;\n}\n\nfunction wrapExpression(expressionText, node) {\n    var ownerDocument = node ? node.ownerDocument : document,\n        closeComment = true,\n        binding,\n        expressionText = trim(expressionText),\n        firstChar = expressionText[0],\n        lastChar = expressionText[expressionText.length - 1],\n        result = [],\n        matches;\n\n    if (firstChar === '#') {\n        if (lastChar === '/') {\n            binding = expressionText.slice(1, -1);\n        } else {\n            binding = expressionText.slice(1);\n            closeComment = false;\n        }\n        if (matches = binding.match(/^([^,\"'{}()\\/:[\\]\\s]+)\\s+([^\\s:].*)/)) {\n            binding = matches[1] + ':' + matches[2];\n        }\n    } else if (firstChar === '/') {\n        // replace only with a closing comment\n    } else if (firstChar === '{' && lastChar === '}') {\n        binding = \"html:\" + trim(expressionText.slice(1, -1));\n    } else {\n        binding = \"text:\" + trim(expressionText);\n    }\n\n    if (binding)\n        result.push(ownerDocument.createComment(\"ko \" + binding));\n    if (closeComment)\n        result.push(ownerDocument.createComment(\"/ko\"));\n    return result;\n};\n\nfunction enableInterpolationMarkup() {\n    addNodePreprocessor(interpolationMarkupPreprocessor);\n}\n\n// Export the preprocessor functions\nvar ko_punches_interpolationMarkup = ko_punches.interpolationMarkup = {\n    preprocessor: interpolationMarkupPreprocessor,\n    enable: enableInterpolationMarkup,\n    wrapExpression: wrapExpression\n};\n\n\nvar dataBind = 'data-bind';\nfunction attributeInterpolationMarkerPreprocessor(node) {\n    if (node.nodeType === 1 && node.attributes.length) {\n        var dataBindAttribute = node.getAttribute(dataBind);\n        for (var attrs = ko.utils.arrayPushAll([], node.attributes), n = attrs.length, i = 0; i < n; ++i) {\n            var attr = attrs[i];\n            if (attr.specified && attr.name != dataBind && attr.value.indexOf('{{') !== -1) {\n                var parts = [], attrValue = '';\n                function addText(text) {\n                    if (text)\n                        parts.push('\"' + text.replace(/\"/g, '\\\\\"') + '\"');\n                }\n                function addExpr(expressionText) {\n                    if (expressionText) {\n                        attrValue = expressionText;\n                        parts.push('ko.unwrap(' + expressionText + ')');\n                    }\n                }\n                parseInterpolationMarkup(attr.value, addText, addExpr);\n\n                if (parts.length > 1) {\n                    attrValue = '\"\"+' + parts.join('+');\n                }\n\n                if (attrValue) {\n                    var attrName = attr.name.toLowerCase();\n                    var attrBinding = ko_punches_attributeInterpolationMarkup.attributeBinding(attrName, attrValue, node) || attributeBinding(attrName, attrValue, node);\n                    if (!dataBindAttribute) {\n                        dataBindAttribute = attrBinding\n                    } else {\n                        dataBindAttribute += ',' + attrBinding;\n                    }\n                    node.setAttribute(dataBind, dataBindAttribute);\n                    // Using removeAttribute instead of removeAttributeNode because IE clears the\n                    // class if you use removeAttributeNode to remove the id.\n                    node.removeAttribute(attr.name);\n                }\n            }\n        }\n    }\n}\n\nfunction attributeBinding(name, value, node) {\n    if (ko.getBindingHandler(name)) {\n        return name + ':' + value;\n    } else {\n        return 'attr.' + name + ':' + value;\n    }\n}\n\nfunction enableAttributeInterpolationMarkup() {\n    addNodePreprocessor(attributeInterpolationMarkerPreprocessor);\n}\n\nvar ko_punches_attributeInterpolationMarkup = ko_punches.attributeInterpolationMarkup = {\n    preprocessor: attributeInterpolationMarkerPreprocessor,\n    enable: enableAttributeInterpolationMarkup,\n    attributeBinding: attributeBinding\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/knockout.punches/index.js\n ** module id = 152\n ** module chunks = 1 2 4 6 7 8 9 10 12 17 18 22 23 24 27 29 30 31 35 36 37 42 53\n **/","'use strict';\n\nvar ko = require('knockout');\nrequire('knockout.punches');\nvar $ = require('jquery');\nvar Raven = require('raven-js');\nvar koHelpers = require('js/koHelpers');\nvar $osf = require('js/osfHelpers');\n\nko.punches.enableAll();\n\nvar MESSAGE_TIMEOUT = 5000;\nvar MIN_FORWARD_TIME = 5;\nvar MAX_FORWARD_TIME = 60;\n\nvar DEFAULT_FORWARD_BOOL = true;\nvar DEFAULT_FORWARD_TIME = 15;\n\n/**\n * Knockout view model for the Forward node settings widget.\n */\nvar ViewModel = function(url, nodeId) {\n\n    var self = this;\n\n    self.boolOptions = [true, false];\n    self.boolLabels = {\n        true: 'Yes',\n        false: 'No'\n    };\n\n    // Forward configuration\n    self.url = ko.observable().extend({\n        ensureHttp: true,\n        url: true,\n        required: true\n    });\n    ko.validation.addAnonymousRule(\n        self.url,\n        koHelpers.makeRegexValidator(\n            new RegExp(nodeId, 'i'),\n            'Components cannot link to themselves',\n            false\n        )\n    );\n    self.label = koHelpers.sanitizedObservable();\n    self.redirectBool = ko.observable(DEFAULT_FORWARD_BOOL);\n    self.redirectSecs = ko.observable(DEFAULT_FORWARD_TIME).extend({\n        required: true,\n        min: MIN_FORWARD_TIME,\n        max: MAX_FORWARD_TIME\n    });\n\n    // Flashed messages\n    self.message = ko.observable('');\n    self.messageClass = ko.observable('text-info');\n\n    self.validators = ko.validatedObservable({\n        url: self.url,\n        redirectBool: self.redirectBool,\n        redirectSecs: self.redirectSecs\n    });\n\n    self.getBoolLabel = function(item) {\n        return self.boolLabels[item];\n    };\n\n    /**\n     * Update the view model from data returned from the server.\n     */\n    self.updateFromData = function(data) {\n        self.url(data.url);\n    self.label(data.label);\n        self.redirectBool(data.redirectBool);\n        self.redirectSecs(data.redirectSecs);\n    };\n\n    self.fetchFromServer = function() {\n        $.ajax({\n            type: 'GET',\n            url: url,\n            dataType: 'json'\n        }).done(function(response) {\n            self.updateFromData(response);\n        }).fail(function(xhr, textStatus, error) {\n            self.changeMessage('Could not retrieve Forward settings at ' +\n                'this time. Please refresh ' +\n                'the page. If the problem persists, email ' +\n                '<a href=\"mailto:support@osf.io\">support@osf.io</a>.',\n                'text-danger');\n            Raven.captureMessage('Could not GET get Forward addon settings.', {\n                url: url,\n                textStatus: textStatus,\n                error: error\n            });\n        });\n    };\n\n    // Initial fetch from server\n    self.fetchFromServer();\n\n    function onSubmitSuccess() {\n        self.changeMessage(\n            'Successfully linked to <a href=\"' + self.url() + '\">' + self.url() + '</a>.',\n            'text-success',\n            MESSAGE_TIMEOUT\n        );\n    }\n\n    function onSubmitError(xhr, status) {\n        self.changeMessage(\n            'Could not change settings. Please try again later.',\n            'text-danger'\n        );\n    }\n\n    /**\n     * Submit new settings.\n     */\n    self.submitSettings = function() {\n        $osf.putJSON(\n            url,\n            ko.toJS(self)\n        ).done(\n            onSubmitSuccess\n        ).fail(\n            onSubmitError\n        );\n    };\n\n    /** Change the flashed message. */\n    self.changeMessage = function(text, css, timeout) {\n        self.message(text);\n        var cssClass = css || 'text-info';\n        self.messageClass(cssClass);\n        if (timeout) {\n            // Reset message after timeout period\n            setTimeout(function() {\n                self.message('');\n                self.messageClass('text-info');\n            }, timeout);\n        }\n    };\n\n};\n\n// Public API\nfunction ForwardConfig(selector, url, nodeId) {\n    var self = this;\n    self.viewModel = new ViewModel(url, nodeId);\n    $osf.applyBindings(self.viewModel, selector);\n}\n\nmodule.exports = ForwardConfig;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../website/addons/forward/static/forwardConfig.js\n ** module id = 355\n ** module chunks = 17\n **/"],"sourceRoot":""}