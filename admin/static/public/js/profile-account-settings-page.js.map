{"version":3,"sources":["webpack:///../website/static/js/pages/profile-account-settings-page.js","webpack:///../~/knockout.punches/index.js?2063***************","webpack:///../website/static/js/accountSettings.js","webpack:///../website/static/js/changeMessage.js"],"names":[],"mappings":";;;;;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,E;;;;;;;ACpBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa,gCAAgC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY,EAAE;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD,EAAE,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,mCAAmC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,OAAO;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,KAAK;AACL;AACA,KAAK,0BAA0B,oBAAoB;AACnD;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,6FAA6F,OAAO;AACpG;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACrkBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,CAAC;;;AAGD;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;;AAET;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA,+BAA+B,uBAAuB,EAAE;AACxD;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA,yBAAyB,kCAAkC;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,wDAAwD;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;;AAGD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,wDAAwD;AACxD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;;;;;;;AChYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA,uC;AACA;AACA,CAAC;;AAED","file":"profile-account-settings-page.js","sourcesContent":["'use strict';\n\nvar $ = require('jquery');\nvar $osf = require('js/osfHelpers.js');\nvar accountSettings = require('js/accountSettings.js');\n\n$(function() {\n    var viewModel = new accountSettings.UserProfileViewModel();\n    $osf.applyBindings(viewModel, '#connectedEmails');\n    viewModel.init();\n\n    $osf.applyBindings(\n        new accountSettings.DeactivateAccountViewModel(),\n        '#deactivateAccount'\n    );\n\n    $osf.applyBindings(\n        new accountSettings.ExportAccountViewModel(),\n        '#exportAccount'\n    );\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../website/static/js/pages/profile-account-settings-page.js\n ** module id = 0\n ** module chunks = 30\n **/","/**\n * @license Knockout.Punches\n * Enhanced binding syntaxes for Knockout 3+\n * (c) Michael Best\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n * Version 0.5.1\n */\nvar ko = require('knockout');\n\n// Add a preprocess function to a binding handler.\nfunction addBindingPreprocessor(bindingKeyOrHandler, preprocessFn) {\n    return chainPreprocessor(getOrCreateHandler(bindingKeyOrHandler), 'preprocess', preprocessFn);\n}\n\n// These utility functions are separated out because they're also used by\n// preprocessBindingProperty\n\n// Get the binding handler or create a new, empty one\nfunction getOrCreateHandler(bindingKeyOrHandler) {\n    return typeof bindingKeyOrHandler === 'object' ? bindingKeyOrHandler :\n        (ko.getBindingHandler(bindingKeyOrHandler) || (ko.bindingHandlers[bindingKeyOrHandler] = {}));\n}\n// Add a preprocess function\nfunction chainPreprocessor(obj, prop, fn) {\n    if (obj[prop]) {\n        // If the handler already has a preprocess function, chain the new\n        // one after the existing one. If the previous function in the chain\n        // returns a falsy value (to remove the binding), the chain ends. This\n        // method allows each function to modify and return the binding value.\n        var previousFn = obj[prop];\n        obj[prop] = function(value, binding, addBinding) {\n            value = previousFn.call(this, value, binding, addBinding);\n            if (value)\n                return fn.call(this, value, binding, addBinding);\n        };\n    } else {\n        obj[prop] = fn;\n    }\n    return obj;\n}\n\n// Add a preprocessNode function to the binding provider. If a\n// function already exists, chain the new one after it. This calls\n// each function in the chain until one modifies the node. This\n// method allows only one function to modify the node.\nfunction addNodePreprocessor(preprocessFn) {\n    var provider = ko.bindingProvider.instance;\n    if (provider.preprocessNode) {\n        var previousPreprocessFn = provider.preprocessNode;\n        provider.preprocessNode = function(node) {\n            var newNodes = previousPreprocessFn.call(this, node);\n            if (!newNodes)\n                newNodes = preprocessFn.call(this, node);\n            return newNodes;\n        };\n    } else {\n        provider.preprocessNode = preprocessFn;\n    }\n}\n\nfunction addBindingHandlerCreator(matchRegex, callbackFn) {\n    var oldGetHandler = ko.getBindingHandler;\n    ko.getBindingHandler = function(bindingKey) {\n        var match;\n        return oldGetHandler(bindingKey) || ((match = bindingKey.match(matchRegex)) && callbackFn(match, bindingKey));\n    };\n}\n\n// Create shortcuts to commonly used ko functions\nvar ko_unwrap = ko.unwrap;\n\n// Create \"punches\" object and export utility functions\nvar ko_punches = ko.punches = {\n    utils: {\n        addBindingPreprocessor: addBindingPreprocessor,\n        addNodePreprocessor: addNodePreprocessor,\n        addBindingHandlerCreator: addBindingHandlerCreator,\n\n        // previous names retained for backwards compitibility\n        setBindingPreprocessor: addBindingPreprocessor,\n        setNodePreprocessor: addNodePreprocessor\n    }\n};\n\nko_punches.enableAll = function () {\n    // Enable interpolation markup\n    enableInterpolationMarkup();\n    enableAttributeInterpolationMarkup();\n\n    // Enable auto-namspacing of attr, css, event, and style\n    enableAutoNamespacedSyntax('attr');\n    enableAutoNamespacedSyntax('css');\n    enableAutoNamespacedSyntax('event');\n    enableAutoNamespacedSyntax('style');\n\n    // Make sure that Knockout knows to bind checked after attr.value (see #40)\n    ko.bindingHandlers.checked.after.push('attr.value');\n\n    // Enable filter syntax for text, html, and attr\n    enableTextFilter('text');\n    enableTextFilter('html');\n    addDefaultNamespacedBindingPreprocessor('attr', filterPreprocessor);\n\n    // Enable wrapped callbacks for click, submit, event, optionsAfterRender, and template options\n    enableWrappedCallback('click');\n    enableWrappedCallback('submit');\n    enableWrappedCallback('optionsAfterRender');\n    addDefaultNamespacedBindingPreprocessor('event', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'beforeRemove', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'afterAdd', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'afterRender', wrappedCallbackPreprocessor);\n};\n// Convert input in the form of `expression | filter1 | filter2:arg1:arg2` to a function call format\n// with filters accessed as ko.filters.filter1, etc.\nfunction filterPreprocessor(input) {\n    // Check if the input contains any | characters; if not, just return\n    if (input.indexOf('|') === -1)\n        return input;\n\n    // Split the input into tokens, in which | and : are individual tokens, quoted strings are ignored, and all tokens are space-trimmed\n    var tokens = input.match(/\"([^\"\\\\]|\\\\.)*\"|'([^'\\\\]|\\\\.)*'|\\|\\||[|:]|[^\\s|:\"'][^|:\"']*[^\\s|:\"']|[^\\s|:\"']/g);\n    if (tokens && tokens.length > 1) {\n        // Append a line so that we don't need a separate code block to deal with the last item\n        tokens.push('|');\n        input = tokens[0];\n        var lastToken, token, inFilters = false, nextIsFilter = false;\n        for (var i = 1, token; token = tokens[i]; ++i) {\n            if (token === '|') {\n                if (inFilters) {\n                    if (lastToken === ':')\n                        input += \"undefined\";\n                    input += ')';\n                }\n                nextIsFilter = true;\n                inFilters = true;\n            } else {\n                if (nextIsFilter) {\n                    input = \"ko.filters['\" + token + \"'](\" + input;\n                } else if (inFilters && token === ':') {\n                    if (lastToken === ':')\n                        input += \"undefined\";\n                    input += \",\";\n                } else {\n                    input += token;\n                }\n                nextIsFilter = false;\n            }\n            lastToken = token;\n        }\n    }\n    return input;\n}\n\n// Set the filter preprocessor for a specific binding\nfunction enableTextFilter(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, filterPreprocessor);\n}\n\nvar filters = {};\n\n// Convert value to uppercase\nfilters.uppercase = function(value) {\n    return String.prototype.toUpperCase.call(ko_unwrap(value));\n};\n\n// Convert value to lowercase\nfilters.lowercase = function(value) {\n    return String.prototype.toLowerCase.call(ko_unwrap(value));\n};\n\n// Return default value if the input value is empty or null\nfilters['default'] = function (value, defaultValue) {\n    value = ko_unwrap(value);\n    if (typeof value === \"function\") {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        return trim(value) === '' ? defaultValue : value;\n    }\n    return value == null || value.length == 0 ? defaultValue : value;\n};\n\n// Return the value with the search string replaced with the replacement string\nfilters.replace = function(value, search, replace) {\n    return String.prototype.replace.call(ko_unwrap(value), search, replace);\n};\n\nfilters.fit = function(value, length, replacement, trimWhere) {\n    value = ko_unwrap(value);\n    if (length && ('' + value).length > length) {\n        replacement = '' + (replacement || '...');\n        length = length - replacement.length;\n        value = '' + value;\n        switch (trimWhere) {\n            case 'left':\n                return replacement + value.slice(-length);\n            case 'middle':\n                var leftLen = Math.ceil(length / 2);\n                return value.substr(0, leftLen) + replacement + value.slice(leftLen-length);\n            default:\n                return value.substr(0, length) + replacement;\n        }\n    } else {\n        return value;\n    }\n};\n\n// Convert a model object to JSON\nfilters.json = function(rootObject, space, replacer) {     // replacer and space are optional\n    return ko.toJSON(rootObject, replacer, space);\n};\n\n// Format a number using the browser's toLocaleString\nfilters.number = function(value) {\n    return (+ko_unwrap(value)).toLocaleString();\n};\n\n// Export the filters object for general access\nko.filters = filters;\n\n// Export the preprocessor functions\nko_punches.textFilter = {\n    preprocessor: filterPreprocessor,\n    enableForBinding: enableTextFilter\n};\n// Support dynamically-created, namespaced bindings. The binding key syntax is\n// \"namespace.binding\". Within a certain namespace, we can dynamically create the\n// handler for any binding. This is particularly useful for bindings that work\n// the same way, but just set a different named value, such as for element\n// attributes or CSS classes.\nvar namespacedBindingMatch = /([^\\.]+)\\.(.+)/, namespaceDivider = '.';\naddBindingHandlerCreator(namespacedBindingMatch, function (match, bindingKey) {\n    var namespace = match[1],\n        namespaceHandler = ko.bindingHandlers[namespace];\n    if (namespaceHandler) {\n        var bindingName = match[2],\n            handlerFn = namespaceHandler.getNamespacedHandler || defaultGetNamespacedHandler,\n            handler = handlerFn.call(namespaceHandler, bindingName, namespace, bindingKey);\n        ko.bindingHandlers[bindingKey] = handler;\n        return handler;\n    }\n});\n\n// Knockout's built-in bindings \"attr\", \"event\", \"css\" and \"style\" include the idea of\n// namespaces, representing it using a single binding that takes an object map of names\n// to values. This default handler translates a binding of \"namespacedName: value\"\n// to \"namespace: {name: value}\" to automatically support those built-in bindings.\nfunction defaultGetNamespacedHandler(name, namespace, namespacedName) {\n    var handler = ko.utils.extend({}, this);\n    function setHandlerFunction(funcName) {\n        if (handler[funcName]) {\n            handler[funcName] = function(element, valueAccessor) {\n                function subValueAccessor() {\n                    var result = {};\n                    result[name] = valueAccessor();\n                    return result;\n                }\n                var args = Array.prototype.slice.call(arguments, 0);\n                args[1] = subValueAccessor;\n                return ko.bindingHandlers[namespace][funcName].apply(this, args);\n            };\n        }\n    }\n    // Set new init and update functions that wrap the originals\n    setHandlerFunction('init');\n    setHandlerFunction('update');\n    // Clear any preprocess function since preprocessing of the new binding would need to be different\n    if (handler.preprocess)\n        handler.preprocess = null;\n    if (ko.virtualElements.allowedBindings[namespace])\n        ko.virtualElements.allowedBindings[namespacedName] = true;\n    return handler;\n}\n\n// Adds a preprocess function for every generated namespace.x binding. This can\n// be called multiple times for the same binding, and the preprocess functions will\n// be chained. If the binding has a custom getNamespacedHandler method, make sure that\n// it's set before this function is used.\nfunction addDefaultNamespacedBindingPreprocessor(namespace, preprocessFn) {\n    var handler = ko.getBindingHandler(namespace);\n    if (handler) {\n        var previousHandlerFn = handler.getNamespacedHandler || defaultGetNamespacedHandler;\n        handler.getNamespacedHandler = function() {\n            return addBindingPreprocessor(previousHandlerFn.apply(this, arguments), preprocessFn);\n        };\n    }\n}\n\nfunction autoNamespacedPreprocessor(value, binding, addBinding) {\n    if (value.charAt(0) !== \"{\")\n        return value;\n\n    // Handle two-level binding specified as \"binding: {key: value}\" by parsing inner\n    // object and converting to \"binding.key: value\"\n    var subBindings = ko.expressionRewriting.parseObjectLiteral(value);\n    ko.utils.arrayForEach(subBindings, function(keyValue) {\n        addBinding(binding + namespaceDivider + keyValue.key, keyValue.value);\n    });\n}\n\n// Set the namespaced preprocessor for a specific binding\nfunction enableAutoNamespacedSyntax(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, autoNamespacedPreprocessor);\n}\n\n// Export the preprocessor functions\nko_punches.namespacedBinding = {\n    defaultGetHandler: defaultGetNamespacedHandler,\n    setDefaultBindingPreprocessor: addDefaultNamespacedBindingPreprocessor,    // for backwards compat.\n    addDefaultBindingPreprocessor: addDefaultNamespacedBindingPreprocessor,\n    preprocessor: autoNamespacedPreprocessor,\n    enableForBinding: enableAutoNamespacedSyntax\n};\n// Wrap a callback function in an anonymous function so that it is called with the appropriate\n// \"this\" value.\nfunction wrappedCallbackPreprocessor(val) {\n    // Matches either an isolated identifier or something ending with a property accessor\n    if (/^([$_a-z][$\\w]*|.+(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i.test(val)) {\n        return 'function(_x,_y,_z){return(' + val + ')(_x,_y,_z);}';\n    } else {\n        return val;\n    }\n}\n\n// Set the wrappedCallback preprocessor for a specific binding\nfunction enableWrappedCallback(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, wrappedCallbackPreprocessor);\n}\n\n// Export the preprocessor functions\nko_punches.wrappedCallback = {\n    preprocessor: wrappedCallbackPreprocessor,\n    enableForBinding: enableWrappedCallback\n};\n// Attach a preprocess function to a specific property of a binding. This allows you to\n// preprocess binding \"options\" using the same preprocess functions that work for bindings.\nfunction addBindingPropertyPreprocessor(bindingKeyOrHandler, property, preprocessFn) {\n    var handler = getOrCreateHandler(bindingKeyOrHandler);\n    if (!handler._propertyPreprocessors) {\n        // Initialize the binding preprocessor\n        chainPreprocessor(handler, 'preprocess', propertyPreprocessor);\n        handler._propertyPreprocessors = {};\n    }\n    // Add the property preprocess function\n    chainPreprocessor(handler._propertyPreprocessors, property, preprocessFn);\n}\n\n// In order to preprocess a binding property, we have to preprocess the binding itself.\n// This preprocess function splits up the binding value and runs each property's preprocess\n// function if it's set.\nfunction propertyPreprocessor(value, binding, addBinding) {\n    if (value.charAt(0) !== \"{\")\n        return value;\n\n    var subBindings = ko.expressionRewriting.parseObjectLiteral(value),\n        resultStrings = [],\n        propertyPreprocessors = this._propertyPreprocessors || {};\n    ko.utils.arrayForEach(subBindings, function(keyValue) {\n        var prop = keyValue.key, propVal = keyValue.value;\n        if (propertyPreprocessors[prop]) {\n            propVal = propertyPreprocessors[prop](propVal, prop, addBinding);\n        }\n        if (propVal) {\n            resultStrings.push(\"'\" + prop + \"':\" + propVal);\n        }\n    });\n    return \"{\" + resultStrings.join(\",\") + \"}\";\n}\n\n// Export the preprocessor functions\nko_punches.preprocessBindingProperty = {\n    setPreprocessor: addBindingPropertyPreprocessor,     // for backwards compat.\n    addPreprocessor: addBindingPropertyPreprocessor\n};\n// Wrap an expression in an anonymous function so that it is called when the event happens\nfunction makeExpressionCallbackPreprocessor(args) {\n    return function expressionCallbackPreprocessor(val) {\n        return 'function('+args+'){return(' + val + ');}';\n    };\n}\n\nvar eventExpressionPreprocessor = makeExpressionCallbackPreprocessor(\"$data,$event\");\n\n// Set the expressionCallback preprocessor for a specific binding\nfunction enableExpressionCallback(bindingKeyOrHandler, args) {\n    var args = Array.prototype.slice.call(arguments, 1).join();\n    addBindingPreprocessor(bindingKeyOrHandler, makeExpressionCallbackPreprocessor(args));\n}\n\n// Export the preprocessor functions\nko_punches.expressionCallback = {\n    makePreprocessor: makeExpressionCallbackPreprocessor,\n    eventPreprocessor: eventExpressionPreprocessor,\n    enableForBinding: enableExpressionCallback\n};\n\n// Create an \"on\" namespace for events to use the expression method\nko.bindingHandlers.on = {\n    getNamespacedHandler: function(eventName) {\n        var handler = ko.getBindingHandler('event' + namespaceDivider + eventName);\n        return addBindingPreprocessor(handler, eventExpressionPreprocessor);\n    }\n};\n// Performance comparison at http://jsperf.com/markup-interpolation-comparison\nfunction parseInterpolationMarkup(textToParse, outerTextCallback, expressionCallback) {\n    function innerParse(text) {\n        var innerMatch = text.match(/^([\\s\\S]*)}}([\\s\\S]*?)\\{\\{([\\s\\S]*)$/);\n        if (innerMatch) {\n            innerParse(innerMatch[1]);\n            outerTextCallback(innerMatch[2]);\n            expressionCallback(innerMatch[3]);\n        } else {\n            expressionCallback(text);\n        }\n    }\n    var outerMatch = textToParse.match(/^([\\s\\S]*?)\\{\\{([\\s\\S]*)}}([\\s\\S]*)$/);\n    if (outerMatch) {\n        outerTextCallback(outerMatch[1]);\n        innerParse(outerMatch[2]);\n        outerTextCallback(outerMatch[3]);\n    }\n}\n\nfunction trim(string) {\n    return string == null ? '' :\n        string.trim ?\n            string.trim() :\n            string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n}\n\nfunction interpolationMarkupPreprocessor(node) {\n    // only needs to work with text nodes\n    if (node.nodeType === 3 && node.nodeValue && node.nodeValue.indexOf('{{') !== -1 && (node.parentNode || {}).nodeName != \"TEXTAREA\") {\n        var nodes = [];\n        function addTextNode(text) {\n            if (text)\n                nodes.push(document.createTextNode(text));\n        }\n        function wrapExpr(expressionText) {\n            if (expressionText)\n                nodes.push.apply(nodes, ko_punches_interpolationMarkup.wrapExpression(expressionText, node));\n        }\n        parseInterpolationMarkup(node.nodeValue, addTextNode, wrapExpr)\n\n        if (nodes.length) {\n            if (node.parentNode) {\n                for (var i = 0, n = nodes.length, parent = node.parentNode; i < n; ++i) {\n                    parent.insertBefore(nodes[i], node);\n                }\n                parent.removeChild(node);\n            }\n            return nodes;\n        }\n    }\n}\n\nif (!ko.virtualElements.allowedBindings.html) {\n    // Virtual html binding\n    // SO Question: http://stackoverflow.com/a/15348139\n    var overridden = ko.bindingHandlers.html.update;\n    ko.bindingHandlers.html.update = function (element, valueAccessor) {\n        if (element.nodeType === 8) {\n            var html = ko_unwrap(valueAccessor());\n            if (html != null) {\n                var parsedNodes = ko.utils.parseHtmlFragment('' + html);\n                ko.virtualElements.setDomNodeChildren(element, parsedNodes);\n            } else {\n                ko.virtualElements.emptyNode(element);\n            }\n        } else {\n            overridden(element, valueAccessor);\n        }\n    };\n    ko.virtualElements.allowedBindings.html = true;\n}\n\nfunction wrapExpression(expressionText, node) {\n    var ownerDocument = node ? node.ownerDocument : document,\n        closeComment = true,\n        binding,\n        expressionText = trim(expressionText),\n        firstChar = expressionText[0],\n        lastChar = expressionText[expressionText.length - 1],\n        result = [],\n        matches;\n\n    if (firstChar === '#') {\n        if (lastChar === '/') {\n            binding = expressionText.slice(1, -1);\n        } else {\n            binding = expressionText.slice(1);\n            closeComment = false;\n        }\n        if (matches = binding.match(/^([^,\"'{}()\\/:[\\]\\s]+)\\s+([^\\s:].*)/)) {\n            binding = matches[1] + ':' + matches[2];\n        }\n    } else if (firstChar === '/') {\n        // replace only with a closing comment\n    } else if (firstChar === '{' && lastChar === '}') {\n        binding = \"html:\" + trim(expressionText.slice(1, -1));\n    } else {\n        binding = \"text:\" + trim(expressionText);\n    }\n\n    if (binding)\n        result.push(ownerDocument.createComment(\"ko \" + binding));\n    if (closeComment)\n        result.push(ownerDocument.createComment(\"/ko\"));\n    return result;\n};\n\nfunction enableInterpolationMarkup() {\n    addNodePreprocessor(interpolationMarkupPreprocessor);\n}\n\n// Export the preprocessor functions\nvar ko_punches_interpolationMarkup = ko_punches.interpolationMarkup = {\n    preprocessor: interpolationMarkupPreprocessor,\n    enable: enableInterpolationMarkup,\n    wrapExpression: wrapExpression\n};\n\n\nvar dataBind = 'data-bind';\nfunction attributeInterpolationMarkerPreprocessor(node) {\n    if (node.nodeType === 1 && node.attributes.length) {\n        var dataBindAttribute = node.getAttribute(dataBind);\n        for (var attrs = ko.utils.arrayPushAll([], node.attributes), n = attrs.length, i = 0; i < n; ++i) {\n            var attr = attrs[i];\n            if (attr.specified && attr.name != dataBind && attr.value.indexOf('{{') !== -1) {\n                var parts = [], attrValue = '';\n                function addText(text) {\n                    if (text)\n                        parts.push('\"' + text.replace(/\"/g, '\\\\\"') + '\"');\n                }\n                function addExpr(expressionText) {\n                    if (expressionText) {\n                        attrValue = expressionText;\n                        parts.push('ko.unwrap(' + expressionText + ')');\n                    }\n                }\n                parseInterpolationMarkup(attr.value, addText, addExpr);\n\n                if (parts.length > 1) {\n                    attrValue = '\"\"+' + parts.join('+');\n                }\n\n                if (attrValue) {\n                    var attrName = attr.name.toLowerCase();\n                    var attrBinding = ko_punches_attributeInterpolationMarkup.attributeBinding(attrName, attrValue, node) || attributeBinding(attrName, attrValue, node);\n                    if (!dataBindAttribute) {\n                        dataBindAttribute = attrBinding\n                    } else {\n                        dataBindAttribute += ',' + attrBinding;\n                    }\n                    node.setAttribute(dataBind, dataBindAttribute);\n                    // Using removeAttribute instead of removeAttributeNode because IE clears the\n                    // class if you use removeAttributeNode to remove the id.\n                    node.removeAttribute(attr.name);\n                }\n            }\n        }\n    }\n}\n\nfunction attributeBinding(name, value, node) {\n    if (ko.getBindingHandler(name)) {\n        return name + ':' + value;\n    } else {\n        return 'attr.' + name + ':' + value;\n    }\n}\n\nfunction enableAttributeInterpolationMarkup() {\n    addNodePreprocessor(attributeInterpolationMarkerPreprocessor);\n}\n\nvar ko_punches_attributeInterpolationMarkup = ko_punches.attributeInterpolationMarkup = {\n    preprocessor: attributeInterpolationMarkerPreprocessor,\n    enable: enableAttributeInterpolationMarkup,\n    attributeBinding: attributeBinding\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/knockout.punches/index.js\n ** module id = 152\n ** module chunks = 1 2 4 6 7 8 9 10 12 17 18 22 23 24 27 29 30 31 35 36 37 42 53\n **/","'use strict';\n\nvar $ = require('jquery');\nvar $osf = require('js/osfHelpers');\nvar bootbox = require('bootbox');\nvar ko = require('knockout');\nvar oop = require('js/oop');\nvar Raven = require('raven-js');\nvar ChangeMessageMixin = require('js/changeMessage');\n\nrequire('knockout.punches');\nko.punches.enableAll();\n\n\nvar UserEmail = oop.defclass({\n    constructor: function(params) {\n        params = params || {};\n        this.address = ko.observable(params.address);\n        this.isConfirmed = ko.observable(params.isConfirmed || false);\n        this.isPrimary = ko.observable(params.isPrimary || false);\n    }\n});\n\n\nvar UserProfile = oop.defclass({\n    constructor: function () {\n\n        this.id = ko.observable();\n        this.emails = ko.observableArray();\n\n        this.primaryEmail = ko.pureComputed(function () {\n            var emails = this.emails();\n            for (var i = 0; i < this.emails().length; i++) {\n                if(emails[i].isPrimary()) {\n                    return emails[i];\n                }\n            }\n            return new UserEmail();\n        }.bind(this));\n\n        this.alternateEmails = ko.pureComputed(function () {\n            var emails = this.emails();\n            var retval = [];\n            for (var i = 0; i < this.emails().length; i++) {\n                if (emails[i].isConfirmed() && !emails[i].isPrimary()) {\n                    retval.push(emails[i]);\n                }\n            }\n            return retval;\n        }.bind(this));\n\n        this.unconfirmedEmails = ko.pureComputed(function () {\n            var emails = this.emails();\n            var retval = [];\n            for (var i = 0; i < this.emails().length; i++) {\n                if(!emails[i].isConfirmed()) {\n                    retval.push(emails[i]);\n                }\n            }\n            return retval;\n        }.bind(this));\n\n    }\n});\n\n\nvar UserProfileClient = oop.defclass({\n    constructor: function () {},\n    urls: {\n        fetch: '/api/v1/profile/',\n        update: '/api/v1/profile/',\n        resend: '/api/v1/resend/'\n    },\n    fetch: function () {\n        var ret = $.Deferred();\n\n        var request = $.get(this.urls.fetch);\n        request.done(function(data) {\n            ret.resolve(this.unserialize(data));\n        }.bind(this));\n        request.fail(function(xhr, status, error) {\n            $osf.growl('Error', 'Could not fetch user profile.', 'danger');\n            Raven.captureMessage('Error fetching user profile', {\n                url: this.urls.fetch,\n                status: status,\n                error: error\n            });\n            ret.reject(xhr, status, error);\n        }.bind(this));\n\n        return ret.promise();\n    },\n    update: function (profile, email) {\n        var url = this.urls.update;\n        if(email) {\n            url = this.urls.resend;\n        }\n        var ret = $.Deferred();\n        var request = $osf.putJSON(\n            url,\n            this.serialize(profile, email)\n        ).done(function (data) {\n            ret.resolve(this.unserialize(data, profile));\n        }.bind(this)).fail(function(xhr, status, error) {\n            if (xhr.status === 400) {\n                $osf.growl('Error', xhr.responseJSON.message_long);\n\n            } else {\n                $osf.growl('Error', 'User profile not updated. Please refresh the page and try ' +\n                'again or contact <a href=\"mailto: support@cos.io\">support@cos.io</a> ' +\n                'if the problem persists.', 'danger');\n            }\n\n            Raven.captureMessage('Error fetching user profile', {\n                url: this.urls.update,\n                status: status,\n                error: error\n            });\n            ret.reject(xhr, status, error);\n        }.bind(this));\n\n        return ret;\n    },\n    serialize: function (profile, email) {\n        if(email){\n            return {\n                id: profile.id(),\n                email: {\n                    address: email.address(),\n                    primary: email.isPrimary(),\n                    confirmed: email.isConfirmed()\n                }\n            };\n        }\n        return {\n            id: profile.id(),\n            emails: ko.utils.arrayMap(profile.emails(), function(email) {\n                return {\n                    address: email.address(),\n                    primary: email.isPrimary(),\n                    confirmed: email.isConfirmed()\n                };\n            })\n\n        };\n    },\n    unserialize: function (data, profile) {\n        if (typeof(profile) === 'undefined') {\n            profile = new UserProfile();\n        }\n\n        profile.id(data.profile.id);\n        profile.emails(\n            ko.utils.arrayMap(data.profile.emails, function (emailData){\n                var email = new UserEmail({\n                    address: emailData.address,\n                    isPrimary: emailData.primary,\n                    isConfirmed: emailData.confirmed\n                });\n                return email;\n            })\n        );\n\n        return profile;\n    }\n});\n\n\nvar UserProfileViewModel = oop.extend(ChangeMessageMixin, {\n    constructor: function() {\n        this.super.constructor.call(this);\n        this.client = new UserProfileClient();\n        this.profile = ko.observable(new UserProfile());\n        this.emailInput = ko.observable('');\n\n    },\n    init: function () {\n        this.client.fetch().done(\n            function(profile) { this.profile(profile); }.bind(this)\n        );\n    },\n    addEmail: function () {\n        this.changeMessage('', 'text-info');\n        var newEmail = this.emailInput().toLowerCase().trim();\n        if(newEmail){\n\n            var email = new UserEmail({\n                address: newEmail\n            });\n\n            // ensure email isn't already in the list\n            for (var i=0; i<this.profile().emails().length; i++) {\n                if (this.profile().emails()[i].address() === email.address()) {\n                    this.changeMessage('Duplicate Email', 'text-warning');\n                    this.emailInput('');\n                    return;\n                }\n            }\n\n            this.profile().emails.push(email);\n\n            this.client.update(this.profile()).done(function (profile) {\n                this.profile(profile);\n\n                var emails = profile.emails();\n                for (var i=0; i<emails.length; i++) {\n                    if (emails[i].address() === email.address()) {\n                        this.emailInput('');\n                        var addrText = $osf.htmlEscape(email.address());\n                        $osf.growl('<em>' + addrText  + '</em> added to your account.','You will receive a confirmation email at <em>' + addrText  + '</em>. Please check your email and confirm.', 'success');\n                        return;\n                    }\n                }\n            }.bind(this)).fail(function(){\n                this.profile().emails.remove(email);\n            }.bind(this));\n        } else {\n            this.changeMessage('Email cannot be empty.', 'text-danger');\n        }\n    },\n    resendConfirmation: function(email){\n        var self = this;\n        self.changeMessage('', 'text-info');\n        var addrText = $osf.htmlEscape(email.address());\n        bootbox.confirm({\n            title: 'Resend Email Confirmation?',\n            message: 'Are you sure that you want to resend email confirmation to ' + '<em>' + addrText + '</em>?',\n            callback: function (confirmed) {\n                if (confirmed) {\n                    self.client.update(self.profile(), email).done(function () {\n                        $osf.growl(\n                            'Email confirmation resent to <em>' + addrText + '</em>',\n                            'You will receive a new confirmation email at <em>' + addrText  + '</em>. Please check your email and confirm.',\n                            'success');\n                    });\n                }\n            },\n            buttons:{\n                confirm:{\n                    label:'Resend'\n                }\n            }\n        });\n    },\n    removeEmail: function (email) {\n        var self = this;\n        self.changeMessage('', 'text-info');\n        if (self.profile().emails().indexOf(email) !== -1) {\n            var addrText = $osf.htmlEscape(email.address());\n            bootbox.confirm({\n                title: 'Remove Email?',\n                message: 'Are you sure that you want to remove ' + '<em>' + addrText + '</em>' + ' from your email list?',\n                callback: function (confirmed) {\n                    if (confirmed) {\n                        self.profile().emails.remove(email);\n                        self.client.update(self.profile()).done(function () {\n                            $osf.growl('Email Removed', '<em>' + addrText + '</em>', 'success');\n                        });\n                    }\n                },\n                buttons:{\n                    confirm:{\n                        label:'Remove',\n                        className:'btn-danger'\n                    }\n                }\n            });\n        } else {\n            $osf.growl('Error', 'Please refresh the page and try again.', 'danger');\n        }\n    },\n    makeEmailPrimary: function (email) {\n        this.changeMessage('', 'text-info');\n        if (this.profile().emails().indexOf(email) !== -1) {\n            this.profile().primaryEmail().isPrimary(false);\n            email.isPrimary(true);\n            this.client.update(this.profile()).done(function () {\n                var addrText = $osf.htmlEscape(email.address());\n                $osf.growl('Made Primary', '<em>' + addrText + '<em>', 'success');\n            });\n        } else {\n            $osf.growl('Error', 'Please refresh the page and try again.', 'danger');\n        }\n    }\n});\n\n\nvar DeactivateAccountViewModel = oop.defclass({\n    constructor: function () {\n        this.success = ko.observable(false);\n    },\n    urls: {\n        'update': '/api/v1/profile/deactivate/'\n    },\n    _requestDeactivation: function() {\n        var request = $osf.postJSON(this.urls.update, {});\n        request.done(function() {\n            $osf.growl('Success', 'An OSF administrator will contact you shortly to confirm your deactivation request.', 'success');\n            this.success(true);\n        }.bind(this));\n        request.fail(function(xhr, status, error) {\n            $osf.growl('Error',\n                'Deactivation request failed. Please contact <a href=\"mailto: support@cos.io\">support@cos.io</a> if the problem persists.',\n                'danger'\n            );\n            Raven.captureMessage('Error requesting account deactivation', {\n                url: this.urls.update,\n                status: status,\n                error: error\n            });\n        }.bind(this));\n        return request;\n    },\n    submit: function () {\n        var self = this;\n        bootbox.confirm({\n            title: 'Request account deactivation?',\n            message: 'Are you sure you want to request account deactivation? An OSF administrator will review your request. If accepted, you ' +\n                     'will <strong>NOT</strong> be able to reactivate your account.',\n            callback: function(confirmed) {\n                if (confirmed) {\n                    return self._requestDeactivation();\n                }\n            },\n            buttons:{\n                confirm:{\n                    label:'Request',\n                    className:'btn-danger'\n                }\n            }\n        });\n    }\n});\n\n\nvar ExportAccountViewModel = oop.defclass({\n    constructor: function () {\n        this.success = ko.observable(false);\n    },\n    urls: {\n        'update': '/api/v1/profile/export/'\n    },\n    _requestExport: function() {\n        var request = $osf.postJSON(this.urls.update, {});\n        request.done(function() {\n            $osf.growl('Success', 'An OSF administrator will contact you shortly to confirm your export request.', 'success');\n            this.success(true);\n        }.bind(this));\n        request.fail(function(xhr, status, error) {\n            $osf.growl('Error',\n                'Export request failed. Please contact <a href=\"mailto: support@cos.io\">support@cos.io</a> if the problem persists.',\n                'danger'\n            );\n            Raven.captureMessage('Error requesting account export', {\n                url: this.urls.update,\n                status: status,\n                error: error\n            });\n        }.bind(this));\n        return request;\n    },\n    submit: function () {\n        var self = this;\n        bootbox.confirm({\n            title: 'Request account export?',\n            message: 'Are you sure you want to request account export?',\n            callback: function(confirmed) {\n                if (confirmed) {\n                    return self._requestExport();\n                }\n            },\n            buttons:{\n                confirm:{\n                    label:'Request'\n                }\n            }\n        });\n    }\n});\n\nmodule.exports = {\n    UserProfileViewModel: UserProfileViewModel,\n    DeactivateAccountViewModel: DeactivateAccountViewModel,\n    ExportAccountViewModel: ExportAccountViewModel\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../website/static/js/accountSettings.js\n ** module id = 378\n ** module chunks = 30\n **/","/**\n * ViewModel mixin for displaying form input help messages.\n * Adds message and messageClass observables that can be changed with the\n * changeMessage method.\n */\n'use strict';\nvar ko = require('knockout');\nvar oop = require('js/oop');\n/** Change the flashed status message */\n\nvar ChangeMessageMixin = oop.defclass({\n    constructor: function() {\n        this.message = ko.observable('');\n        this.messageClass = ko.observable('text-info');\n    },\n    changeMessage: function(text, css, timeout) {\n        var self = this;\n        if (typeof text === 'function') {\n            text = text();\n        }\n        self.message(text);\n        var cssClass = css || 'text-info';\n        self.messageClass(cssClass);\n        if (timeout) {\n            // Reset message after timeout period\n            window.setTimeout(function () {\n                self.message('');\n                self.messageClass('text-info');\n            }, timeout);\n        }\n    },\n    resetMessage: function() {\n        this.message('');\n        this.messageClass('text-info');        \n    }\n});\n\nmodule.exports = ChangeMessageMixin;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../website/static/js/changeMessage.js\n ** module id = 379\n ** module chunks = 30 33 34 38 40 47 49\n **/"],"sourceRoot":""}