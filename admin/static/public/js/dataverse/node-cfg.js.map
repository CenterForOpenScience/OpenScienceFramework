{"version":3,"sources":["webpack:///../website/addons/dataverse/static/node-cfg.js","webpack:///../~/knockout.punches/index.js?2063***","webpack:///../website/addons/dataverse/static/dataverseNodeConfig.js"],"names":[],"mappings":";;;;;AAAA;;AAEA;AACA;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mGAAmG;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;;AAEA,wDAAwD,WAAW;AACnE;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,aAAa,gCAAgC;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,YAAY,EAAE;AAC/D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD,EAAE,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,mCAAmC;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2EAA2E,OAAO;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,KAAK;AACL;AACA,KAAK,0BAA0B,oBAAoB;AACnD;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,6FAA6F,OAAO;AACpG;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;ACrkBA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC,sCAAsC;AACtC,qCAAqC;;AAErC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"dataverse/node-cfg.js","sourcesContent":["var DataverseNodeConfig = require('./dataverseNodeConfig.js');\n\nvar url = window.contextVars.node.urls.api + 'dataverse/settings/';\nnew DataverseNodeConfig('#dataverseScope', url);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../website/addons/dataverse/static/node-cfg.js\n ** module id = 0\n ** module chunks = 6\n **/","/**\n * @license Knockout.Punches\n * Enhanced binding syntaxes for Knockout 3+\n * (c) Michael Best\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\n * Version 0.5.1\n */\nvar ko = require('knockout');\n\n// Add a preprocess function to a binding handler.\nfunction addBindingPreprocessor(bindingKeyOrHandler, preprocessFn) {\n    return chainPreprocessor(getOrCreateHandler(bindingKeyOrHandler), 'preprocess', preprocessFn);\n}\n\n// These utility functions are separated out because they're also used by\n// preprocessBindingProperty\n\n// Get the binding handler or create a new, empty one\nfunction getOrCreateHandler(bindingKeyOrHandler) {\n    return typeof bindingKeyOrHandler === 'object' ? bindingKeyOrHandler :\n        (ko.getBindingHandler(bindingKeyOrHandler) || (ko.bindingHandlers[bindingKeyOrHandler] = {}));\n}\n// Add a preprocess function\nfunction chainPreprocessor(obj, prop, fn) {\n    if (obj[prop]) {\n        // If the handler already has a preprocess function, chain the new\n        // one after the existing one. If the previous function in the chain\n        // returns a falsy value (to remove the binding), the chain ends. This\n        // method allows each function to modify and return the binding value.\n        var previousFn = obj[prop];\n        obj[prop] = function(value, binding, addBinding) {\n            value = previousFn.call(this, value, binding, addBinding);\n            if (value)\n                return fn.call(this, value, binding, addBinding);\n        };\n    } else {\n        obj[prop] = fn;\n    }\n    return obj;\n}\n\n// Add a preprocessNode function to the binding provider. If a\n// function already exists, chain the new one after it. This calls\n// each function in the chain until one modifies the node. This\n// method allows only one function to modify the node.\nfunction addNodePreprocessor(preprocessFn) {\n    var provider = ko.bindingProvider.instance;\n    if (provider.preprocessNode) {\n        var previousPreprocessFn = provider.preprocessNode;\n        provider.preprocessNode = function(node) {\n            var newNodes = previousPreprocessFn.call(this, node);\n            if (!newNodes)\n                newNodes = preprocessFn.call(this, node);\n            return newNodes;\n        };\n    } else {\n        provider.preprocessNode = preprocessFn;\n    }\n}\n\nfunction addBindingHandlerCreator(matchRegex, callbackFn) {\n    var oldGetHandler = ko.getBindingHandler;\n    ko.getBindingHandler = function(bindingKey) {\n        var match;\n        return oldGetHandler(bindingKey) || ((match = bindingKey.match(matchRegex)) && callbackFn(match, bindingKey));\n    };\n}\n\n// Create shortcuts to commonly used ko functions\nvar ko_unwrap = ko.unwrap;\n\n// Create \"punches\" object and export utility functions\nvar ko_punches = ko.punches = {\n    utils: {\n        addBindingPreprocessor: addBindingPreprocessor,\n        addNodePreprocessor: addNodePreprocessor,\n        addBindingHandlerCreator: addBindingHandlerCreator,\n\n        // previous names retained for backwards compitibility\n        setBindingPreprocessor: addBindingPreprocessor,\n        setNodePreprocessor: addNodePreprocessor\n    }\n};\n\nko_punches.enableAll = function () {\n    // Enable interpolation markup\n    enableInterpolationMarkup();\n    enableAttributeInterpolationMarkup();\n\n    // Enable auto-namspacing of attr, css, event, and style\n    enableAutoNamespacedSyntax('attr');\n    enableAutoNamespacedSyntax('css');\n    enableAutoNamespacedSyntax('event');\n    enableAutoNamespacedSyntax('style');\n\n    // Make sure that Knockout knows to bind checked after attr.value (see #40)\n    ko.bindingHandlers.checked.after.push('attr.value');\n\n    // Enable filter syntax for text, html, and attr\n    enableTextFilter('text');\n    enableTextFilter('html');\n    addDefaultNamespacedBindingPreprocessor('attr', filterPreprocessor);\n\n    // Enable wrapped callbacks for click, submit, event, optionsAfterRender, and template options\n    enableWrappedCallback('click');\n    enableWrappedCallback('submit');\n    enableWrappedCallback('optionsAfterRender');\n    addDefaultNamespacedBindingPreprocessor('event', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'beforeRemove', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'afterAdd', wrappedCallbackPreprocessor);\n    addBindingPropertyPreprocessor('template', 'afterRender', wrappedCallbackPreprocessor);\n};\n// Convert input in the form of `expression | filter1 | filter2:arg1:arg2` to a function call format\n// with filters accessed as ko.filters.filter1, etc.\nfunction filterPreprocessor(input) {\n    // Check if the input contains any | characters; if not, just return\n    if (input.indexOf('|') === -1)\n        return input;\n\n    // Split the input into tokens, in which | and : are individual tokens, quoted strings are ignored, and all tokens are space-trimmed\n    var tokens = input.match(/\"([^\"\\\\]|\\\\.)*\"|'([^'\\\\]|\\\\.)*'|\\|\\||[|:]|[^\\s|:\"'][^|:\"']*[^\\s|:\"']|[^\\s|:\"']/g);\n    if (tokens && tokens.length > 1) {\n        // Append a line so that we don't need a separate code block to deal with the last item\n        tokens.push('|');\n        input = tokens[0];\n        var lastToken, token, inFilters = false, nextIsFilter = false;\n        for (var i = 1, token; token = tokens[i]; ++i) {\n            if (token === '|') {\n                if (inFilters) {\n                    if (lastToken === ':')\n                        input += \"undefined\";\n                    input += ')';\n                }\n                nextIsFilter = true;\n                inFilters = true;\n            } else {\n                if (nextIsFilter) {\n                    input = \"ko.filters['\" + token + \"'](\" + input;\n                } else if (inFilters && token === ':') {\n                    if (lastToken === ':')\n                        input += \"undefined\";\n                    input += \",\";\n                } else {\n                    input += token;\n                }\n                nextIsFilter = false;\n            }\n            lastToken = token;\n        }\n    }\n    return input;\n}\n\n// Set the filter preprocessor for a specific binding\nfunction enableTextFilter(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, filterPreprocessor);\n}\n\nvar filters = {};\n\n// Convert value to uppercase\nfilters.uppercase = function(value) {\n    return String.prototype.toUpperCase.call(ko_unwrap(value));\n};\n\n// Convert value to lowercase\nfilters.lowercase = function(value) {\n    return String.prototype.toLowerCase.call(ko_unwrap(value));\n};\n\n// Return default value if the input value is empty or null\nfilters['default'] = function (value, defaultValue) {\n    value = ko_unwrap(value);\n    if (typeof value === \"function\") {\n        return value;\n    }\n    if (typeof value === \"string\") {\n        return trim(value) === '' ? defaultValue : value;\n    }\n    return value == null || value.length == 0 ? defaultValue : value;\n};\n\n// Return the value with the search string replaced with the replacement string\nfilters.replace = function(value, search, replace) {\n    return String.prototype.replace.call(ko_unwrap(value), search, replace);\n};\n\nfilters.fit = function(value, length, replacement, trimWhere) {\n    value = ko_unwrap(value);\n    if (length && ('' + value).length > length) {\n        replacement = '' + (replacement || '...');\n        length = length - replacement.length;\n        value = '' + value;\n        switch (trimWhere) {\n            case 'left':\n                return replacement + value.slice(-length);\n            case 'middle':\n                var leftLen = Math.ceil(length / 2);\n                return value.substr(0, leftLen) + replacement + value.slice(leftLen-length);\n            default:\n                return value.substr(0, length) + replacement;\n        }\n    } else {\n        return value;\n    }\n};\n\n// Convert a model object to JSON\nfilters.json = function(rootObject, space, replacer) {     // replacer and space are optional\n    return ko.toJSON(rootObject, replacer, space);\n};\n\n// Format a number using the browser's toLocaleString\nfilters.number = function(value) {\n    return (+ko_unwrap(value)).toLocaleString();\n};\n\n// Export the filters object for general access\nko.filters = filters;\n\n// Export the preprocessor functions\nko_punches.textFilter = {\n    preprocessor: filterPreprocessor,\n    enableForBinding: enableTextFilter\n};\n// Support dynamically-created, namespaced bindings. The binding key syntax is\n// \"namespace.binding\". Within a certain namespace, we can dynamically create the\n// handler for any binding. This is particularly useful for bindings that work\n// the same way, but just set a different named value, such as for element\n// attributes or CSS classes.\nvar namespacedBindingMatch = /([^\\.]+)\\.(.+)/, namespaceDivider = '.';\naddBindingHandlerCreator(namespacedBindingMatch, function (match, bindingKey) {\n    var namespace = match[1],\n        namespaceHandler = ko.bindingHandlers[namespace];\n    if (namespaceHandler) {\n        var bindingName = match[2],\n            handlerFn = namespaceHandler.getNamespacedHandler || defaultGetNamespacedHandler,\n            handler = handlerFn.call(namespaceHandler, bindingName, namespace, bindingKey);\n        ko.bindingHandlers[bindingKey] = handler;\n        return handler;\n    }\n});\n\n// Knockout's built-in bindings \"attr\", \"event\", \"css\" and \"style\" include the idea of\n// namespaces, representing it using a single binding that takes an object map of names\n// to values. This default handler translates a binding of \"namespacedName: value\"\n// to \"namespace: {name: value}\" to automatically support those built-in bindings.\nfunction defaultGetNamespacedHandler(name, namespace, namespacedName) {\n    var handler = ko.utils.extend({}, this);\n    function setHandlerFunction(funcName) {\n        if (handler[funcName]) {\n            handler[funcName] = function(element, valueAccessor) {\n                function subValueAccessor() {\n                    var result = {};\n                    result[name] = valueAccessor();\n                    return result;\n                }\n                var args = Array.prototype.slice.call(arguments, 0);\n                args[1] = subValueAccessor;\n                return ko.bindingHandlers[namespace][funcName].apply(this, args);\n            };\n        }\n    }\n    // Set new init and update functions that wrap the originals\n    setHandlerFunction('init');\n    setHandlerFunction('update');\n    // Clear any preprocess function since preprocessing of the new binding would need to be different\n    if (handler.preprocess)\n        handler.preprocess = null;\n    if (ko.virtualElements.allowedBindings[namespace])\n        ko.virtualElements.allowedBindings[namespacedName] = true;\n    return handler;\n}\n\n// Adds a preprocess function for every generated namespace.x binding. This can\n// be called multiple times for the same binding, and the preprocess functions will\n// be chained. If the binding has a custom getNamespacedHandler method, make sure that\n// it's set before this function is used.\nfunction addDefaultNamespacedBindingPreprocessor(namespace, preprocessFn) {\n    var handler = ko.getBindingHandler(namespace);\n    if (handler) {\n        var previousHandlerFn = handler.getNamespacedHandler || defaultGetNamespacedHandler;\n        handler.getNamespacedHandler = function() {\n            return addBindingPreprocessor(previousHandlerFn.apply(this, arguments), preprocessFn);\n        };\n    }\n}\n\nfunction autoNamespacedPreprocessor(value, binding, addBinding) {\n    if (value.charAt(0) !== \"{\")\n        return value;\n\n    // Handle two-level binding specified as \"binding: {key: value}\" by parsing inner\n    // object and converting to \"binding.key: value\"\n    var subBindings = ko.expressionRewriting.parseObjectLiteral(value);\n    ko.utils.arrayForEach(subBindings, function(keyValue) {\n        addBinding(binding + namespaceDivider + keyValue.key, keyValue.value);\n    });\n}\n\n// Set the namespaced preprocessor for a specific binding\nfunction enableAutoNamespacedSyntax(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, autoNamespacedPreprocessor);\n}\n\n// Export the preprocessor functions\nko_punches.namespacedBinding = {\n    defaultGetHandler: defaultGetNamespacedHandler,\n    setDefaultBindingPreprocessor: addDefaultNamespacedBindingPreprocessor,    // for backwards compat.\n    addDefaultBindingPreprocessor: addDefaultNamespacedBindingPreprocessor,\n    preprocessor: autoNamespacedPreprocessor,\n    enableForBinding: enableAutoNamespacedSyntax\n};\n// Wrap a callback function in an anonymous function so that it is called with the appropriate\n// \"this\" value.\nfunction wrappedCallbackPreprocessor(val) {\n    // Matches either an isolated identifier or something ending with a property accessor\n    if (/^([$_a-z][$\\w]*|.+(\\.\\s*[$_a-z][$\\w]*|\\[.+\\]))$/i.test(val)) {\n        return 'function(_x,_y,_z){return(' + val + ')(_x,_y,_z);}';\n    } else {\n        return val;\n    }\n}\n\n// Set the wrappedCallback preprocessor for a specific binding\nfunction enableWrappedCallback(bindingKeyOrHandler) {\n    addBindingPreprocessor(bindingKeyOrHandler, wrappedCallbackPreprocessor);\n}\n\n// Export the preprocessor functions\nko_punches.wrappedCallback = {\n    preprocessor: wrappedCallbackPreprocessor,\n    enableForBinding: enableWrappedCallback\n};\n// Attach a preprocess function to a specific property of a binding. This allows you to\n// preprocess binding \"options\" using the same preprocess functions that work for bindings.\nfunction addBindingPropertyPreprocessor(bindingKeyOrHandler, property, preprocessFn) {\n    var handler = getOrCreateHandler(bindingKeyOrHandler);\n    if (!handler._propertyPreprocessors) {\n        // Initialize the binding preprocessor\n        chainPreprocessor(handler, 'preprocess', propertyPreprocessor);\n        handler._propertyPreprocessors = {};\n    }\n    // Add the property preprocess function\n    chainPreprocessor(handler._propertyPreprocessors, property, preprocessFn);\n}\n\n// In order to preprocess a binding property, we have to preprocess the binding itself.\n// This preprocess function splits up the binding value and runs each property's preprocess\n// function if it's set.\nfunction propertyPreprocessor(value, binding, addBinding) {\n    if (value.charAt(0) !== \"{\")\n        return value;\n\n    var subBindings = ko.expressionRewriting.parseObjectLiteral(value),\n        resultStrings = [],\n        propertyPreprocessors = this._propertyPreprocessors || {};\n    ko.utils.arrayForEach(subBindings, function(keyValue) {\n        var prop = keyValue.key, propVal = keyValue.value;\n        if (propertyPreprocessors[prop]) {\n            propVal = propertyPreprocessors[prop](propVal, prop, addBinding);\n        }\n        if (propVal) {\n            resultStrings.push(\"'\" + prop + \"':\" + propVal);\n        }\n    });\n    return \"{\" + resultStrings.join(\",\") + \"}\";\n}\n\n// Export the preprocessor functions\nko_punches.preprocessBindingProperty = {\n    setPreprocessor: addBindingPropertyPreprocessor,     // for backwards compat.\n    addPreprocessor: addBindingPropertyPreprocessor\n};\n// Wrap an expression in an anonymous function so that it is called when the event happens\nfunction makeExpressionCallbackPreprocessor(args) {\n    return function expressionCallbackPreprocessor(val) {\n        return 'function('+args+'){return(' + val + ');}';\n    };\n}\n\nvar eventExpressionPreprocessor = makeExpressionCallbackPreprocessor(\"$data,$event\");\n\n// Set the expressionCallback preprocessor for a specific binding\nfunction enableExpressionCallback(bindingKeyOrHandler, args) {\n    var args = Array.prototype.slice.call(arguments, 1).join();\n    addBindingPreprocessor(bindingKeyOrHandler, makeExpressionCallbackPreprocessor(args));\n}\n\n// Export the preprocessor functions\nko_punches.expressionCallback = {\n    makePreprocessor: makeExpressionCallbackPreprocessor,\n    eventPreprocessor: eventExpressionPreprocessor,\n    enableForBinding: enableExpressionCallback\n};\n\n// Create an \"on\" namespace for events to use the expression method\nko.bindingHandlers.on = {\n    getNamespacedHandler: function(eventName) {\n        var handler = ko.getBindingHandler('event' + namespaceDivider + eventName);\n        return addBindingPreprocessor(handler, eventExpressionPreprocessor);\n    }\n};\n// Performance comparison at http://jsperf.com/markup-interpolation-comparison\nfunction parseInterpolationMarkup(textToParse, outerTextCallback, expressionCallback) {\n    function innerParse(text) {\n        var innerMatch = text.match(/^([\\s\\S]*)}}([\\s\\S]*?)\\{\\{([\\s\\S]*)$/);\n        if (innerMatch) {\n            innerParse(innerMatch[1]);\n            outerTextCallback(innerMatch[2]);\n            expressionCallback(innerMatch[3]);\n        } else {\n            expressionCallback(text);\n        }\n    }\n    var outerMatch = textToParse.match(/^([\\s\\S]*?)\\{\\{([\\s\\S]*)}}([\\s\\S]*)$/);\n    if (outerMatch) {\n        outerTextCallback(outerMatch[1]);\n        innerParse(outerMatch[2]);\n        outerTextCallback(outerMatch[3]);\n    }\n}\n\nfunction trim(string) {\n    return string == null ? '' :\n        string.trim ?\n            string.trim() :\n            string.toString().replace(/^[\\s\\xa0]+|[\\s\\xa0]+$/g, '');\n}\n\nfunction interpolationMarkupPreprocessor(node) {\n    // only needs to work with text nodes\n    if (node.nodeType === 3 && node.nodeValue && node.nodeValue.indexOf('{{') !== -1 && (node.parentNode || {}).nodeName != \"TEXTAREA\") {\n        var nodes = [];\n        function addTextNode(text) {\n            if (text)\n                nodes.push(document.createTextNode(text));\n        }\n        function wrapExpr(expressionText) {\n            if (expressionText)\n                nodes.push.apply(nodes, ko_punches_interpolationMarkup.wrapExpression(expressionText, node));\n        }\n        parseInterpolationMarkup(node.nodeValue, addTextNode, wrapExpr)\n\n        if (nodes.length) {\n            if (node.parentNode) {\n                for (var i = 0, n = nodes.length, parent = node.parentNode; i < n; ++i) {\n                    parent.insertBefore(nodes[i], node);\n                }\n                parent.removeChild(node);\n            }\n            return nodes;\n        }\n    }\n}\n\nif (!ko.virtualElements.allowedBindings.html) {\n    // Virtual html binding\n    // SO Question: http://stackoverflow.com/a/15348139\n    var overridden = ko.bindingHandlers.html.update;\n    ko.bindingHandlers.html.update = function (element, valueAccessor) {\n        if (element.nodeType === 8) {\n            var html = ko_unwrap(valueAccessor());\n            if (html != null) {\n                var parsedNodes = ko.utils.parseHtmlFragment('' + html);\n                ko.virtualElements.setDomNodeChildren(element, parsedNodes);\n            } else {\n                ko.virtualElements.emptyNode(element);\n            }\n        } else {\n            overridden(element, valueAccessor);\n        }\n    };\n    ko.virtualElements.allowedBindings.html = true;\n}\n\nfunction wrapExpression(expressionText, node) {\n    var ownerDocument = node ? node.ownerDocument : document,\n        closeComment = true,\n        binding,\n        expressionText = trim(expressionText),\n        firstChar = expressionText[0],\n        lastChar = expressionText[expressionText.length - 1],\n        result = [],\n        matches;\n\n    if (firstChar === '#') {\n        if (lastChar === '/') {\n            binding = expressionText.slice(1, -1);\n        } else {\n            binding = expressionText.slice(1);\n            closeComment = false;\n        }\n        if (matches = binding.match(/^([^,\"'{}()\\/:[\\]\\s]+)\\s+([^\\s:].*)/)) {\n            binding = matches[1] + ':' + matches[2];\n        }\n    } else if (firstChar === '/') {\n        // replace only with a closing comment\n    } else if (firstChar === '{' && lastChar === '}') {\n        binding = \"html:\" + trim(expressionText.slice(1, -1));\n    } else {\n        binding = \"text:\" + trim(expressionText);\n    }\n\n    if (binding)\n        result.push(ownerDocument.createComment(\"ko \" + binding));\n    if (closeComment)\n        result.push(ownerDocument.createComment(\"/ko\"));\n    return result;\n};\n\nfunction enableInterpolationMarkup() {\n    addNodePreprocessor(interpolationMarkupPreprocessor);\n}\n\n// Export the preprocessor functions\nvar ko_punches_interpolationMarkup = ko_punches.interpolationMarkup = {\n    preprocessor: interpolationMarkupPreprocessor,\n    enable: enableInterpolationMarkup,\n    wrapExpression: wrapExpression\n};\n\n\nvar dataBind = 'data-bind';\nfunction attributeInterpolationMarkerPreprocessor(node) {\n    if (node.nodeType === 1 && node.attributes.length) {\n        var dataBindAttribute = node.getAttribute(dataBind);\n        for (var attrs = ko.utils.arrayPushAll([], node.attributes), n = attrs.length, i = 0; i < n; ++i) {\n            var attr = attrs[i];\n            if (attr.specified && attr.name != dataBind && attr.value.indexOf('{{') !== -1) {\n                var parts = [], attrValue = '';\n                function addText(text) {\n                    if (text)\n                        parts.push('\"' + text.replace(/\"/g, '\\\\\"') + '\"');\n                }\n                function addExpr(expressionText) {\n                    if (expressionText) {\n                        attrValue = expressionText;\n                        parts.push('ko.unwrap(' + expressionText + ')');\n                    }\n                }\n                parseInterpolationMarkup(attr.value, addText, addExpr);\n\n                if (parts.length > 1) {\n                    attrValue = '\"\"+' + parts.join('+');\n                }\n\n                if (attrValue) {\n                    var attrName = attr.name.toLowerCase();\n                    var attrBinding = ko_punches_attributeInterpolationMarkup.attributeBinding(attrName, attrValue, node) || attributeBinding(attrName, attrValue, node);\n                    if (!dataBindAttribute) {\n                        dataBindAttribute = attrBinding\n                    } else {\n                        dataBindAttribute += ',' + attrBinding;\n                    }\n                    node.setAttribute(dataBind, dataBindAttribute);\n                    // Using removeAttribute instead of removeAttributeNode because IE clears the\n                    // class if you use removeAttributeNode to remove the id.\n                    node.removeAttribute(attr.name);\n                }\n            }\n        }\n    }\n}\n\nfunction attributeBinding(name, value, node) {\n    if (ko.getBindingHandler(name)) {\n        return name + ':' + value;\n    } else {\n        return 'attr.' + name + ':' + value;\n    }\n}\n\nfunction enableAttributeInterpolationMarkup() {\n    addNodePreprocessor(attributeInterpolationMarkerPreprocessor);\n}\n\nvar ko_punches_attributeInterpolationMarkup = ko_punches.attributeInterpolationMarkup = {\n    preprocessor: attributeInterpolationMarkerPreprocessor,\n    enable: enableAttributeInterpolationMarkup,\n    attributeBinding: attributeBinding\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/knockout.punches/index.js\n ** module id = 152\n ** module chunks = 1 2 4 6 7 8 9 10 12 17 18 22 23 24 27 29 30 31 35 36 37 42 53\n **/","/**\n * Module that controls the Dataverse node settings. Includes Knockout view-model\n * for syncing data.\n */\n\nvar ko = require('knockout');\nvar bootbox = require('bootbox');\nrequire('knockout.punches');\nvar Raven = require('raven-js');\n\nvar $osf = require('js/osfHelpers');\n\nvar $modal = $('#dataverseInputCredentials');\n\nko.punches.enableAll();\n\nfunction ViewModel(url) {\n    var self = this;\n    const otherString = 'Other (Please Specify)';\n\n    self.addonName = 'Dataverse';\n    self.url = url;\n    self.urls = ko.observable();\n    self.apiToken = ko.observable();\n\n    self.ownerName = ko.observable();\n    self.nodeHasAuth = ko.observable(false);\n    self.userHasAuth = ko.observable(false);\n    self.userIsOwner = ko.observable(false);\n    self.validCredentials = ko.observable(false);\n    self.loadedSettings = ko.observable(false);\n    self.loadedDatasets = ko.observable(false);\n    self.submitting = ko.observable(false);\n\n    self.dataverses = ko.observableArray([]);\n    self.datasets = ko.observableArray([]);\n\n    self.savedDatasetDoi = ko.observable();\n    self.savedDatasetTitle = ko.observable();\n    self.savedDataverseAlias = ko.observable();\n    self.savedDataverseTitle = ko.observable();\n    self.datasetWasFound = ko.observable(false);\n\n    self.accounts = ko.observable([]);\n    self.hosts = ko.observableArray([]);\n    self.selectedHost = ko.observable();    // Host specified in select element\n    self.customHost = ko.observable();      // Host specified in input element\n    self.savedHost = ko.observable();       // Configured host\n\n    // Designated host, specified from select or input element\n    self.host = ko.pureComputed(function() {\n        return self.useCustomHost() ? self.customHost() : self.selectedHost();\n    });\n    // Hosts visible in select element. Includes presets and \"Other\" option\n    self.visibleHosts = ko.pureComputed(function() {\n        return self.hosts().concat([otherString]);\n    });\n    // Whether to use select element or input element for host designation\n    self.useCustomHost = ko.pureComputed(function() {\n        return self.selectedHost() === otherString;\n    });\n    self.showApiTokenInput = ko.pureComputed(function() {\n        return Boolean(self.selectedHost());\n    });\n    self.tokenUrl = ko.pureComputed(function() {\n       return self.host() ? 'https://' + self.host() + '/account/apitoken' : null;\n    });\n    self.savedHostUrl = ko.pureComputed(function() {\n        return 'https://' + self.savedHost();\n    });\n\n    self.messages = {\n        userSettingsError: ko.pureComputed(function() {\n            return 'Could not retrieve settings. Please refresh the page or ' +\n                'contact <a href=\"mailto: support@osf.io\">support@osf.io</a> if the ' +\n                'problem persists.';\n        }),\n        confirmDeauth: ko.pureComputed(function() {\n            return 'Are you sure you want to remove this ' + self.addonName + ' account?';\n        }),\n        confirmAuth: ko.pureComputed(function() {\n            return 'Are you sure you want to authorize this project with your ' + self.addonName + ' access token?';\n        }),\n        deauthorizeSuccess: ko.pureComputed(function() {\n            return 'Disconnected ' + self.addonName + '.';\n        }),\n        deauthorizeFail: ko.pureComputed(function() {\n            return 'Could not disconnect because of an error. Please try again later.';\n        }),\n        authInvalid: ko.pureComputed(function() {\n            return 'The API token provided for ' + self.host() + ' is invalid.';\n        }),\n        authError: ko.pureComputed(function() {\n            return 'Sorry, but there was a problem connecting to that instance of Dataverse. It ' +\n                'is likely that the instance hasn\\'t been upgraded to Dataverse 4.0. If you ' +\n                'have any questions or believe this to be an error, please contact ' +\n                'support@osf.io.';\n        }),\n        tokenImportSuccess: ko.pureComputed(function() {\n            return 'Successfully imported access token from profile.';\n        }),\n        tokenImportError: ko.pureComputed(function() {\n            return 'Error occurred while importing access token.';\n        }),\n        updateAccountsError: ko.pureComputed(function() {\n            return 'Could not retrieve ' + self.addonName + ' account list at ' +\n                'this time. Please refresh the page. If the problem persists, email ' +\n                '<a href=\"mailto:support@osf.io\">support@osf.io</a>.';\n        }),\n        datasetDeaccessioned: ko.pureComputed(function() {\n            return 'This dataset has already been deaccessioned on Dataverse ' +\n                'and cannot be connected to the OSF.';\n        }),\n        forbiddenCharacters: ko.pureComputed(function() {\n            return 'This dataset cannot be connected due to forbidden characters ' +\n                'in one or more of the dataset\\'s file names. This issue has been forwarded to our ' +\n                'development team.';\n        }),\n        setInfoSuccess: ko.pureComputed(function() {\n            var filesUrl = window.contextVars.node.urls.web + 'files/';\n            return 'Successfully linked dataset \\'' + self.savedDatasetTitle() + '\\'. Go to the <a href=\"' +\n                filesUrl + '\">Files page</a> to view your content.';\n        }),\n        setDatasetError: ko.pureComputed(function() {\n            return 'Could not connect to this dataset. Please refresh the page or ' +\n                'contact <a href=\"mailto: support@osf.io\">support@osf.io</a> if the ' +\n                'problem persists.';\n        }),\n        getDatasetsError: ko.pureComputed(function() {\n            return 'Could not load datasets. Please refresh the page or ' +\n                'contact <a href=\"mailto: support@osf.io\">support@osf.io</a> if the ' +\n                'problem persists.';\n        })\n    };\n\n    self.savedDatasetUrl = ko.pureComputed(function() {\n        return (self.urls()) ? self.urls().datasetPrefix + self.savedDatasetDoi() : null;\n    });\n    self.savedDataverseUrl = ko.pureComputed(function() {\n        return (self.urls()) ? self.urls().dataversePrefix + self.savedDataverseAlias() : null;\n    });\n\n    self.selectedDataverseAlias = ko.observable();\n    self.selectedDatasetDoi = ko.observable();\n    self.selectedDataverseTitle = ko.pureComputed(function() {\n        for (var i = 0; i < self.dataverses().length; i++) {\n            var data = self.dataverses()[i];\n            if (data.alias === self.selectedDataverseAlias()) {\n                return data.title;\n            }\n        }\n        return null;\n    });\n    self.selectedDatasetTitle = ko.pureComputed(function() {\n        for (var i = 0; i < self.datasets().length; i++) {\n            var data = self.datasets()[i];\n            if (data.doi === self.selectedDatasetDoi()) {\n                return data.title;\n            }\n        }\n        return null;\n    });\n    self.dataverseHasDatasets = ko.pureComputed(function() {\n        return self.datasets().length > 0;\n    });\n\n    self.showDatasetSelect = ko.pureComputed(function() {\n        return self.loadedDatasets() && self.dataverseHasDatasets();\n    });\n    self.showNoDatasets = ko.pureComputed(function() {\n        return self.loadedDatasets() && !self.dataverseHasDatasets();\n    });\n    self.showLinkedDataset = ko.pureComputed(function() {\n        return self.savedDatasetDoi();\n    });\n    self.showLinkDataverse = ko.pureComputed(function() {\n        return self.userHasAuth() && !self.nodeHasAuth() && self.loadedSettings();\n    });\n    self.credentialsChanged = ko.pureComputed(function() {\n        return self.nodeHasAuth() && !self.validCredentials();\n    });\n    self.showInputCredentials = ko.pureComputed(function() {\n        return (self.credentialsChanged() && self.userIsOwner()) ||\n            (!self.userHasAuth() && !self.nodeHasAuth() && self.loadedSettings());\n    });\n    self.hasDataverses = ko.pureComputed(function() {\n        return self.dataverses().length > 0;\n    });\n    self.showNotFound = ko.pureComputed(function() {\n        return self.savedDatasetDoi() && self.loadedDatasets() && !self.datasetWasFound();\n    });\n    self.showSubmitDataset = ko.pureComputed(function() {\n        return self.nodeHasAuth() && self.validCredentials() && self.userIsOwner();\n    });\n    self.enableSubmitDataset = ko.pureComputed(function() {\n        return !self.submitting() && self.dataverseHasDatasets() &&\n            self.savedDatasetDoi() !== self.selectedDatasetDoi();\n    });\n\n    self.showSettings = ko.pureComputed(function() {\n        return self.nodeHasAuth() && self.validCredentials();\n    });\n    self.showImport = ko.pureComputed(function() {\n        return self.userHasAuth() && !self.nodeHasAuth() && self.loadedSettings();\n    });\n    self.showTokenCreateButton = ko.pureComputed(function() {\n        return !self.userHasAuth() && !self.nodeHasAuth() && self.loadedSettings();\n    });\n\n    // Flashed messages\n    self.message = ko.observable('');\n    self.messageClass = ko.observable('text-info');\n\n    // Update above observables with data from the server\n    $.ajax({\n        url: url,\n        type: 'GET',\n        dataType: 'json'\n    }).done(function(response) {\n        // Update view model\n        self.updateFromData(response.result);\n        self.loadedSettings(true);\n    }).fail(function(xhr, textStatus, error) {\n        self.changeMessage(self.messages.userSettingsError, 'text-danger');\n        Raven.captureMessage('Could not GET dataverse settings', {\n            url: url,\n            textStatus: textStatus,\n            error: error\n        });\n    });\n\n    self.selectionChanged = function() {\n        self.changeMessage('','');\n    };\n}\n\n/**\n * Update the view model from data returned from the server.\n */\nViewModel.prototype.updateFromData = function(data) {\n    var self = this;\n    self.urls(data.urls);\n    self.ownerName(data.ownerName);\n    self.nodeHasAuth(data.nodeHasAuth);\n    self.userHasAuth(data.userHasAuth);\n    self.userIsOwner(data.userIsOwner);\n    self.hosts(data.hosts);\n\n    if (self.nodeHasAuth()) {\n        self.savedHost(data.dataverseHost);\n        self.dataverses(data.dataverses);\n        self.savedDataverseAlias(data.savedDataverse.alias);\n        self.savedDataverseTitle(data.savedDataverse.title);\n        self.selectedDataverseAlias(data.savedDataverse.alias);\n        self.savedDatasetDoi(data.savedDataset.doi);\n        self.savedDatasetTitle(data.savedDataset.title);\n        self.validCredentials(data.connected);\n        if (self.userIsOwner()) {\n            self.getDatasets(); // Sets datasets, selectedDatasetDoi\n        }\n    }\n};\n\n/** Reset all fields from Dataverse host selection modal */\nViewModel.prototype.clearModal = function() {\n    var self = this;\n    self.message('');\n    self.messageClass('text-info');\n    self.apiToken(null);\n    self.selectedHost(null);\n    self.customHost(null);\n};\n\nViewModel.prototype.setInfo = function() {\n    var self = this;\n    self.submitting(true);\n    return $osf.postJSON(\n        self.urls().set,\n        ko.toJS({\n            dataverse: {\n                alias: self.selectedDataverseAlias\n            },\n            dataset: {\n                doi: self.selectedDatasetDoi\n            }\n        })\n    ).done(function() {\n        self.submitting(false);\n        self.savedDataverseAlias(self.selectedDataverseAlias());\n        self.savedDataverseTitle(self.selectedDataverseTitle());\n        self.savedDatasetDoi(self.selectedDatasetDoi());\n        self.savedDatasetTitle(self.selectedDatasetTitle());\n        self.datasetWasFound(true);\n        self.changeMessage(self.messages.setInfoSuccess, 'text-success');\n    }).fail(function(xhr, textStatus, error) {\n        self.submitting(false);\n        var errorMessage = (xhr.status === 410) ? self.messages.datasetDeaccessioned :\n            (xhr.status = 406) ? self.messages.forbiddenCharacters : self.messages.setDatasetError;\n        self.changeMessage(errorMessage, 'text-danger');\n        Raven.captureMessage('Could not authenticate with Dataverse', {\n            url: self.urls().set,\n            textStatus: textStatus,\n            error: error\n        });\n    });\n};\n\n/**\n * Looks for dataset in list of datasets when first loaded.\n * This prevents an additional request to the server, but requires additional logic.\n */\nViewModel.prototype.findDataset = function() {\n    var self = this;\n    for (var i in self.datasets()) {\n        if (self.datasets()[i].doi === self.savedDatasetDoi()) {\n            self.datasetWasFound(true);\n            return;\n        }\n    }\n};\n\nViewModel.prototype.getDatasets = function() {\n    var self = this;\n    self.datasets([]);\n    self.loadedDatasets(false);\n    return $osf.postJSON(\n        self.urls().getDatasets,\n        ko.toJS({\n            alias: self.selectedDataverseAlias\n        })\n    ).done(function(response) {\n        // Don't update if another Dataverse has been selected\n        if (response.alias === self.selectedDataverseAlias()) {\n            self.datasets(response.datasets);\n            self.loadedDatasets(true);\n            self.selectedDatasetDoi(self.savedDatasetDoi());\n            self.findDataset();\n        }\n    }).fail(function(xhr, status, error) {\n        self.changeMessage(self.messages.getDatasetsError, 'text-danger');\n        Raven.captureMessage('Could not GET datasets', {\n            url: self.urls().getDatasets,\n            textStatus: status,\n            error: error\n        });\n    });\n};\n\n/** Send POST request to authorize Dataverse */\nViewModel.prototype.sendAuth = function() {\n    var self = this;\n\n    // Selection should not be empty\n    if( !self.selectedHost() ){\n        self.changeMessage(\"Please select a Dataverse repository.\", 'text-danger');\n        return;\n    }\n    var url = self.urls().create;\n    return $osf.postJSON(\n        url,\n        ko.toJS({\n            host: self.host,\n            api_token: self.apiToken\n        })\n    ).done(function() {\n        self.clearModal();\n        $modal.modal('hide');\n        self.userHasAuth(true);\n        self.importAuth();\n    }).fail(function(xhr, textStatus, error) {\n        var errorMessage = (xhr.status === 401) ? self.messages.authInvalid : self.messages.authError;\n        self.changeMessage(errorMessage, 'text-danger');\n        Raven.captureMessage('Could not authenticate with Dataverse', {\n            url: url,\n            textStatus: textStatus,\n            error: error\n        });\n    });\n};\n\nViewModel.prototype.fetchAccounts = function() {\n    var self = this;\n    var ret = $.Deferred();\n    var request = $.get(self.urls().accounts);\n    request.then(function(data) {\n        ret.resolve(data.accounts);\n    });\n    request.fail(function(xhr, textStatus, error) {\n        self.changeMessage(self.messages.updateAccountsError(), 'text-danger');\n        Raven.captureMessage('Could not GET ' + self.addonName + ' accounts for user', {\n            url: self.url,\n            textStatus: textStatus,\n            error: error\n        });\n        ret.reject(xhr, textStatus, error);\n    });\n    return ret.promise();\n};\n\nViewModel.prototype.updateAccounts = function() {\n    var self = this;\n    return self.fetchAccounts()\n        .done(function(accounts) {\n            self.accounts(\n                $.map(accounts, function(account) {\n                    return {\n                        name: account.display_name,\n                        id: account.id\n                    };\n                })\n            );\n        });\n};\n\nViewModel.prototype.onImportSuccess = function(response) {\n    var self = this;\n    var msg = response.message || self.messages.tokenImportSuccess();\n    // Update view model based on response\n    self.changeMessage(msg, 'text-success', 3000);\n    self.updateFromData(response.result);\n};\n\nViewModel.prototype.onImportError = function(xhr, status, error) {\n    var self = this;\n    self.changeMessage(self.messages.tokenImportError(), 'text-danger');\n    Raven.captureMessage('Failed to import ' + self.addonName + ' access token.', {\n        xhr: xhr,\n        status: status,\n        error: error\n    });\n};\n\n/**\n * Allows a user to create an access token from the nodeSettings page\n */\nViewModel.prototype.connectAccount = function() {\n    var self = this;\n\n    window.oauthComplete = function(res) {\n        // Update view model based on response\n        self.changeMessage(self.messages.connectAccountSuccess(), 'text-success', 3000);\n        self.importAuth.call(self);\n    };\n    window.open(self.urls().auth);\n};\n\nViewModel.prototype.connectExistingAccount = function(account_id) {\n    var self = this;\n\n    return $osf.putJSON(\n        self.urls().importAuth, {\n            external_account_id: account_id\n        }\n    ).then(self.onImportSuccess.bind(self), self.onImportError.bind(self));\n};\n\n/**\n *  Send PUT request to import access token from user profile.\n */\nViewModel.prototype.importAuth = function() {\n    var self = this;\n    self.updateAccounts()\n        .then(function(){\n            if (self.accounts().length > 1) {\n                bootbox.prompt({\n                    title: 'Choose ' + self.addonName + ' Access Token to Import',\n                    inputType: 'select',\n                    inputOptions: ko.utils.arrayMap(\n                        self.accounts(),\n                        function(item) {\n                            return {\n                                text: item.name,\n                                value: item.id\n                            };\n                        }\n                    ),\n                    value: self.accounts()[0].id,\n                    callback: function(accountId) {\n                        if (accountId) {\n                            self.connectExistingAccount.call(self, (accountId));\n                        }\n                    },\n                    buttons:{\n                        confirm:{\n                            label: 'Import'\n                        }\n                    }\n                });\n            } else {\n                bootbox.confirm({\n                    title: 'Import ' + self.addonName + ' Access Token?',\n                    message: self.messages.confirmAuth(),\n                    callback: function(confirmed) {\n                        if (confirmed) {\n                            self.connectExistingAccount.call(self, (self.accounts()[0].id));\n                        }\n                    },\n                    buttons:{\n                        confirm:{\n                            label:'Import'\n                        }\n                    }\n                });\n            }\n        });\n};\n\n/**\n * Send DELETE request to deauthorize this node.\n */\nViewModel.prototype._deauthorizeConfirm = function() {\n    var self = this;\n    var request = $.ajax({\n        url: self.urls().deauthorize,\n        type: 'DELETE'\n    });\n    request.done(function() {\n        // Update observables\n        self.nodeHasAuth(false);\n        self.clearModal();\n        self.changeMessage(self.messages.deauthorizeSuccess(), 'text-warning', 3000);\n    });\n    request.fail(function(xhr, textStatus, error) {\n        self.changeMessage(self.messages.deauthorizeFail(), 'text-danger');\n        Raven.captureMessage('Could not deauthorize ' + self.addonName + ' account from node', {\n            url: self.urls().deauthorize,\n            textStatus: textStatus,\n            error: error\n        });\n    });\n    return request;\n};\n\n/** Pop up a confirmation to deauthorize addon from this node.\n *  Send DELETE request if confirmed.\n */\nViewModel.prototype.deauthorize = function() {\n    var self = this;\n    bootbox.confirm({\n        title: 'Disconnect ' + self.addonName + ' Account?',\n        message: self.messages.confirmDeauth(),\n        callback: function(confirmed) {\n            if (confirmed) {\n                self._deauthorizeConfirm();\n            }\n        },\n        buttons:{\n            confirm:{\n                label: 'Disconnect',\n                className: 'btn-danger'\n            }\n        }\n    });\n};\n\n/** Change the flashed status message */\nViewModel.prototype.changeMessage = function(text, css, timeout) {\n    var self = this;\n    if (typeof text === 'function') {\n        text = text();\n    }\n    self.message(text);\n    var cssClass = css || 'text-info';\n    self.messageClass(cssClass);\n    if (timeout) {\n        // Reset message after timeout period\n        setTimeout(function() {\n            self.message('');\n            self.messageClass('text-info');\n        }, timeout);\n    }\n};\n\nfunction DataverseNodeConfig(selector, url) {\n    // Initialization code\n    var self = this;\n    self.selector = selector;\n    self.url = url;\n    // On success, instantiate and bind the ViewModel\n    self.viewModel = new ViewModel(url);\n    $osf.applyBindings(self.viewModel, '#dataverseScope');\n}\nmodule.exports = DataverseNodeConfig;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../website/addons/dataverse/static/dataverseNodeConfig.js\n ** module id = 193\n ** module chunks = 6\n **/"],"sourceRoot":""}