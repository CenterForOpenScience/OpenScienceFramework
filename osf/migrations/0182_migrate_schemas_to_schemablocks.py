# -*- coding: utf-8 -*-
# Generated by Django 1.11.13 on 2018-09-26 20:08
from __future__ import unicode_literals

import re
import logging
from django.db import migrations
from osf.models.base import generate_object_id

logger = logging.getLogger(__file__)

# Dict to map original schema formats to new blocks types
FORMAT_TYPE_TO_TYPE_MAP = {
    ('multiselect', 'choose'): 'multi-select-input',
    (None, 'multiselect'): 'multi-select-input',
    (None, 'choose'): 'single-select-input',
    ('osf-upload-open', 'osf-upload'): 'file-input',
    ('osf-upload-toggle', 'osf-upload'): 'file-input',
    ('singleselect', 'choose'): 'single-select-input',
    ('text', 'string'): 'short-text-input',
    ('textarea', 'osf-author-import'): 'contributors-input',
    ('textarea', 'string'): 'long-text-input',
    ('textarea-lg', None): 'long-text-input',
    ('textarea-lg', 'string'): 'long-text-input',
    ('textarea-xl', 'string'): 'long-text-input',
}

def remove_version_1_schemas(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    assert RegistrationSchema.objects.filter(schema_version=1, abstractnode__isnull=False).count() == 0
    assert RegistrationSchema.objects.filter(schema_version=1, draftregistration__isnull=False).count() == 0
    RegistrationSchema.objects.filter(schema_version=1).delete()

def update_schemaless_registrations(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    AbstractNode = state.get_model('osf', 'abstractnode')

    open_ended_schema = RegistrationSchema.objects.get(name='Open-Ended Registration')
    open_ended_meta = {
        '{}'.format(open_ended_schema._id): {
            'summary': {
                'comments': [],
                'extra': [],
                'value': ''
            }
        }
    }

    schemaless_regs_with_meta = AbstractNode.objects.filter(type='osf.registration', registered_schema__isnull=True).exclude(registered_meta={})
    schemaless_regs_without_meta = AbstractNode.objects.filter(type='osf.registration', registered_schema__isnull=True, registered_meta={})

    for reg in schemaless_regs_without_meta.all():
        reg.registered_schema.add(open_ended_schema)
        reg.registered_meta = open_ended_meta
        reg.save()

    for reg in schemaless_regs_with_meta.all():
        reg.registered_schema.add(RegistrationSchema.objects.get(_id=reg.registered_meta.keys()[0]))

def update_schema_configs(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    for rs in RegistrationSchema.objects.all():
        if rs.schema.get('description', False):
            rs.description = rs.schema['description']
            rs.save()

def unset_schema_configs(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    RegistrationSchema.objects.update(config=dict())

def unmap_schemablocks(state, schema):
    RegistrationSchemaBlock = state.get_model('osf', 'registrationschemablock')
    RegistrationSchemaBlock.objects.all().delete()

def noop(*args, **kwargs):
    pass

def create_block(state, schema_id, block_type, display_text='', required=False, help_text='',
        answer_id=None, chunk_id='', example_text=''):
    RegistrationSchemaBlock = state.get_model('osf', 'registrationschemablock')

    return RegistrationSchemaBlock.objects.create(
        schema_id=schema_id,
        block_type=block_type,
        required=required,
        display_text=display_text,
        help_text=help_text,
        answer_id=answer_id,
        chunk_id=chunk_id,
        example_text=example_text
    )

# Split question multiple choice options into their own blocks
def split_options_into_blocks(state, rs, question, chunk_id):
    for option in question.get('options', []):
        answer_text = option if isinstance(option, basestring) else option.get('text')
        help_text = '' if isinstance(option, basestring) else option.get('tooltip', '')

        create_block(
            state,
            rs.id,
            'select-input-option',
            display_text=answer_text,
            help_text=help_text,
            chunk_id=chunk_id,
        )

def get_answer_id(question):
    """
    Answer ids will map to the user's response
    """
    return question.get('qid', '') or question.get('id', '')

def strip_html(string_with_html):
    """
    Some original schemas have html in the description/help text.  Just replacing this with empty strings.
    """
    stripped_html = re.sub('<.*?>', '', string_with_html)
    return stripped_html

def find_title_description_help_example(rs, question):
    """
    Schemas are inconsistent with regards to the information going into "title",
    "description", and "help" blocks.

    :returns tuple, title, description, help, example strings

    """
    title = question.get('title', '')
    description = strip_html(question.get('description', ''))
    help = strip_html(question.get('help', ''))
    example = ''

    schema_name = rs.schema.get('name', '')
    # Descriptions that contain any of these keywords
    # are turned into help text instead.
    help_text_keywords = [
        'please',
        'choose',
        'provide',
        'format',
        'describe',
        'who',
        'what',
        'when',
        'where',
        'use',
        'you',
        'your',
        'skip',
        'enter',
    ]

    if title:
        if schema_name in ['OSF Preregistration', 'Prereg Challenge']:
            # These two schemas have clear "example" text in the "help" section
            example = help
            help = description
            description = ''
        else:
            for keyword in help_text_keywords:
                if keyword in description.lower():
                    help = description
                    description = ''
                    break
    else:
        # if no title, description text is moved to title.
        title = description
        description = ''

    return title, description, help, example

def format_property(question, property, index):
    """
    Modify a subquestion's qid, title, description, and help text, because
    these are often absent.
    - Modify a subquestion's qid to be of the format "parent-id.current-id", to
      reflect its nested nature, to ensure uniqueness
    - For the first nested subquestion, transfer the parent's title, description, and help.
    """
    property['qid'] = '{}.{}'.format(get_answer_id(question) or '', property.get('id', ''))
    if not index:
        title = question.get('title', '')
        description = question.get('description', '')
        help = question.get('help', '')
        if not property.get('title', '') and not property.get('description'):
            property['title'] = title
        if not property.get('description', ''):
            property['description'] = description
        if not property.get('help', ''):
            property['help'] = help
    return property


def format_question(state, rs, question, sub=False):
    """
    Split the original question from the schema into multiple schema blocks, all of
    which have the same chunk_id, to link them.
    """
    # If there are subquestions, recurse and format subquestions
    if question.get('properties'):
        # Creates section or subsection
        create_block(
            state,
            rs.id,
            block_type='subsection-heading' if sub else 'section-heading',
            display_text=question.get('title', '') or question.get('description', ''),
        )
        for index, property in enumerate(question.get('properties')):
            format_question(state, rs, format_property(question, property, index), sub=True)
    else:
        # All form blocks related to a particular question share the same chunk_id.
        chunk_id = generate_object_id()
        title, description, help, example = find_title_description_help_example(rs, question)

        # Creates question title block
        create_block(
            state,
            rs.id,
            block_type='question-title',
            display_text=title,
            help_text='' if description else help,
            example_text=example,
            chunk_id=chunk_id
        )

        # Creates paragraph block (question description)
        if description:
            create_block(
                state,
                rs.id,
                block_type='paragraph',
                display_text=description,
                help_text=help,
                chunk_id=chunk_id,
            )

        # Creates question input block - this block will correspond to an answer
        # Map the original schema section format to the new block_type, and create a schema block
        block_type = FORMAT_TYPE_TO_TYPE_MAP[(question.get('format'), question.get('type'))]
        create_block(
            state,
            rs.id,
            block_type,
            required=question.get('required', False),
            chunk_id=chunk_id,
            answer_id=get_answer_id(question)
        )

        # If there are multiple choice answers, create blocks for these as well.
        split_options_into_blocks(state, rs, question, chunk_id)


def map_schema_to_schemablocksv2(state, schema):
    RegistrationSchema = state.get_model('osf', 'registrationschema')
    # Migrating all schemas, active or not, to form blocks, since registration
    # metadata matching old schemas will still need to be formatted.
    schemas = RegistrationSchema.objects.all()
    for rs in schemas:
        logger.info('Migrating schema {}, version {} to schema blocks.'.format(rs.schema.get('name'), rs.schema_version))
        for page in rs.schema['pages']:
            # Create page heading block
            create_block(
                state,
                rs.id,
                'page-heading',
                display_text=strip_html(page.get('title', '')),
                help_text=strip_html(page.get('description', ''))
            )
            for question in page['questions']:
                format_question(state, rs, question)


class Migration(migrations.Migration):

    dependencies = [
        ('osf', '0181_add_schema_block_models'),
    ]

    operations = [
        migrations.RunPython(remove_version_1_schemas, noop),
        migrations.RunPython(update_schemaless_registrations, noop),
        migrations.RunPython(update_schema_configs, unset_schema_configs),
        migrations.RunPython(map_schema_to_schemablocksv2, unmap_schemablocks)
    ]
