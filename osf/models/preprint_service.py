# -*- coding: utf-8 -*-
import urlparse

from dirtyfields import DirtyFieldsMixin
from django.db import models
from django.utils import timezone
from django.utils.functional import cached_property
from django.contrib.contenttypes.fields import GenericRelation
from django.core.exceptions import ValidationError
from guardian.shortcuts import assign_perm, remove_perm, get_perms

from framework.postcommit_tasks.handlers import enqueue_postcommit_task
from framework.auth.core import get_user
from framework.exceptions import PermissionsError
from osf.models import NodeLog, Subject
from osf.models.mixins import ReviewableMixin
from osf.models.validators import validate_subject_hierarchy
from osf.utils.fields import NonNaiveDateTimeField
from osf.utils.workflows import DefaultStates
from osf.utils.permissions import expand_permissions, DEFAULT_CONTRIBUTOR_PERMISSIONS
from website.preprints.tasks import on_preprint_updated, get_and_set_preprint_identifiers
from website.project.licenses import set_license
from website.project import signals as project_signals
from website.util import api_v2_url
from website import settings, mails
from osf.exceptions import (
    PreprintStateError,
    ValidationValueError
)
from osf.models.base import BaseModel, GuidMixin
from osf.models.contributor import PreprintContributor, RecentlyAddedContributor
from osf.models.identifiers import IdentifierMixin, Identifier
from osf.models.user import OSFUser


class PreprintService(DirtyFieldsMixin, GuidMixin, IdentifierMixin, ReviewableMixin, BaseModel):
    provider = models.ForeignKey('osf.PreprintProvider',
                                 on_delete=models.SET_NULL,
                                 related_name='preprint_services',
                                 null=True, blank=True, db_index=True)
    node = models.ForeignKey('osf.AbstractNode', on_delete=models.SET_NULL,
                             related_name='preprints',
                             null=True, blank=True, db_index=True)
    is_published = models.BooleanField(default=False, db_index=True)
    date_published = NonNaiveDateTimeField(null=True, blank=True)
    original_publication_date = NonNaiveDateTimeField(null=True, blank=True)
    license = models.ForeignKey('osf.NodeLicenseRecord',
                                on_delete=models.SET_NULL, null=True, blank=True)

    subjects = models.ManyToManyField(blank=True, to='osf.Subject', related_name='preprint_services')

    identifiers = GenericRelation(Identifier, related_query_name='preprintservices')
    preprint_doi_created = NonNaiveDateTimeField(default=None, null=True, blank=True)

    _contributors = models.ManyToManyField(OSFUser,
                                           through=PreprintContributor,
                                           related_name='preprintservices')
    class Meta:
        unique_together = ('node', 'provider')
        permissions = (
            ('view_preprintservice', 'Can view preprint service details in the admin app.'),
            ('ADMIN', 'Can do anything the preprint'),
            ('EDIT', 'Can edit the preprint'),
            ('READ', 'Can read the preprint')
        )

    def __unicode__(self):
        return '{} preprint (guid={}) of {}'.format('published' if self.is_published else 'unpublished', self._id, self.node.__unicode__() if self.node else None)

    @property
    def contributors(self):
        # NOTE: _order field is generated by order_with_respect_to = 'node'
        return self._contributors.order_by('contributor___order')

    @property
    def verified_publishable(self):
        return self.is_published and self.node.is_preprint and not self.node.is_deleted

    @property
    def primary_file(self):
        if not self.node:
            return
        return self.node.preprint_file

    @property
    def article_doi(self):
        if not self.node:
            return
        return self.node.preprint_article_doi

    @property
    def preprint_doi(self):
        return self.get_identifier_value('doi')

    @property
    def is_preprint_orphan(self):
        if not self.node:
            return
        return self.node.is_preprint_orphan

    @cached_property
    def subject_hierarchy(self):
        return [
            s.object_hierarchy for s in self.subjects.exclude(children__in=self.subjects.all())
        ]

    @property
    def deep_url(self):
        # Required for GUID routing
        return '/preprints/{}/'.format(self._primary_key)

    @property
    def url(self):
        if (self.provider.domain_redirect_enabled and self.provider.domain) or self.provider._id == 'osf':
            return '/{}/'.format(self._id)

        return '/preprints/{}/{}/'.format(self.provider._id, self._id)

    @property
    def absolute_url(self):
        return urlparse.urljoin(
            self.provider.domain if self.provider.domain_redirect_enabled else settings.DOMAIN,
            self.url
        )

    @property
    def absolute_api_v2_url(self):
        path = '/preprints/{}/'.format(self._id)
        return api_v2_url(path)

    def is_contributor(self, user):
        """Return whether ``user`` is a contributor on this node."""
        return user is not None and PreprintContributor.objects.filter(user=user, preprintservice=self).exists()

    def get_subjects(self):
        ret = []
        for subj_list in self.subject_hierarchy:
            subj_hierarchy = []
            for subj in subj_list:
                if subj:
                    subj_hierarchy += ({'id': subj._id, 'text': subj.text}, )
            if subj_hierarchy:
                ret.append(subj_hierarchy)
        return ret

    def set_subjects(self, preprint_subjects, auth):
        if not self.has_permission(auth.user, 'ADMIN'):
            raise PermissionsError('Only admins can change a preprint\'s subjects.')

        old_subjects = list(self.subjects.values_list('id', flat=True))
        self.subjects.clear()
        for subj_list in preprint_subjects:
            subj_hierarchy = []
            for s in subj_list:
                subj_hierarchy.append(s)
            if subj_hierarchy:
                validate_subject_hierarchy(subj_hierarchy)
                for s_id in subj_hierarchy:
                    self.subjects.add(Subject.load(s_id))

        self.save(old_subjects=old_subjects)

    def set_primary_file(self, preprint_file, auth, save=False):
        if not self.has_permission(auth.user, 'ADMIN'):
            raise PermissionsError('Only admins can change a preprint\'s primary file.')

        if preprint_file.node != self.node or preprint_file.provider != 'osfstorage':
            raise ValueError('This file is not a valid primary file for this preprint.')

        existing_file = self.node.preprint_file
        self.node.preprint_file = preprint_file

        # only log if updating the preprint file, not adding for the first time
        if existing_file:
            self.node.add_log(
                action=NodeLog.PREPRINT_FILE_UPDATED,
                params={
                    'preprint': self._id
                },
                auth=auth,
                save=False
            )

        if save:
            self.save()
            self.node.save()

    def set_published(self, published, auth, save=False):
        if not self.has_permission(auth.user, 'ADMIN'):
            raise PermissionsError('Only admins can publish a preprint.')

        if self.is_published and not published:
            raise ValueError('Cannot unpublish preprint.')

        self.is_published = published

        if published:
            if not (self.node.preprint_file and self.node.preprint_file.node == self.node):
                raise ValueError('Preprint node is not a valid preprint; cannot publish.')
            if not self.provider:
                raise ValueError('Preprint provider not specified; cannot publish.')
            if not self.subjects.exists():
                raise ValueError('Preprint must have at least one subject to be published.')
            self.date_published = timezone.now()
            self.node._has_abandoned_preprint = False

            # In case this provider is ever set up to use a reviews workflow, put this preprint in a sensible state
            self.machine_state = DefaultStates.ACCEPTED.value
            self.date_last_transitioned = self.date_published

            self.node.add_log(
                action=NodeLog.PREPRINT_INITIATED,
                params={
                    'preprint': self._id
                },
                auth=auth,
                save=False,
            )

            if not self.node.is_public:
                self.node.set_privacy(
                    self.node.PUBLIC,
                    auth=None,
                    log=True
                )

            # This should be called after all fields for EZID metadta have been set
            enqueue_postcommit_task(get_and_set_preprint_identifiers, (), {'preprint_id': self._id}, celery=True)

            self._send_preprint_confirmation(auth)

        if save:
            self.node.save()
            self.save()

    def set_preprint_license(self, license_detail, auth, save=False):
        license_record, license_changed = set_license(self, license_detail, auth, node_type='preprint')

        if license_changed:
            self.node.add_log(
                action=NodeLog.PREPRINT_LICENSE_UPDATED,
                params={
                    'preprint': self._id,
                    'new_license': license_record.node_license.name
                },
                auth=auth,
                save=False
            )

        if save:
            self.save()

    def set_identifier_values(self, doi, save=False):
        self.set_identifier_value('doi', doi)
        self.preprint_doi_created = timezone.now()

        if save:
            self.save()

    def save(self, *args, **kwargs):
        first_save = not bool(self.pk)
        saved_fields = self.get_dirty_fields() or []
        old_subjects = kwargs.pop('old_subjects', [])
        ret = super(PreprintService, self).save(*args, **kwargs)

        if (not first_save and 'is_published' in saved_fields) or self.is_published:
            enqueue_postcommit_task(on_preprint_updated, (self._id,), {'old_subjects': old_subjects}, celery=True)
        return ret

    def _send_preprint_confirmation(self, auth):
        # Send creator confirmation email
        if self.provider._id == 'osf':
            email_template = getattr(mails, 'PREPRINT_CONFIRMATION_DEFAULT')
        else:
            email_template = getattr(mails, 'PREPRINT_CONFIRMATION_BRANDED')(self.provider)

        mails.send_mail(
            auth.user.username,
            email_template,
            user=auth.user,
            node=self.node,
            preprint=self,
            osf_contact_email=settings.OSF_CONTACT_EMAIL,
        )

    def get_permissions(self, user):
        return get_perms(user, self)

    def has_permission(self, user, permission):
        """Check whether user has permission.

        :param User user: User to test
        :param str permission: Required permission
        :returns: User has required permission
        """
        if not user:
            return False
        return user.has_perm(permission, self)

    def set_permissions(self, user, permissions, validate=True, save=False):
        # Ensure that user's permissions cannot be lowered if they are the only admin
        if isinstance(user, PreprintContributor):
            user = user.user

        if validate and (self.has_permission(user, 'ADMIN') and 'ADMIN' not in permissions):
            admin_contribs = PreprintContributor.objects.filter(preprintservice=self, admin=True)
            if admin_contribs.count() <= 1:
                raise PreprintStateError('Must have at least one registered admin contributor')

        contrib_obj = PreprintContributor.objects.get(preprintservice=self, user=user)
        assign_perm(permissions, contrib_obj, self)
        contrib_obj.save()
        if save:
            self.save()

    # TODO: Remove save parameter
    def add_permission(self, user, permission, save=False):
        """Grant permission to a user.

        :param User user: User to grant permission to
        :param str permission: Permission to grant
        :param bool save: Save changes
        :raises: ValueError if user already has permission
        """
        contributor = user.contributor_set.get(preprintservice=self)
        if not contributor.has_perm(permission, self):
            permission_to_add = expand_permissions(permission)
            assign_perm(permission_to_add, contributor, self)
            contributor.save()
        elif contributor.has_perm(permission, self):
            raise ValueError('User already has permission {0}'.format(permission))
        if save:
            self.save()

    # TODO: Remove save parameter
    def remove_permission(self, user, permission, save=False):
        """Revoke permission from a user.

        :param User user: User to revoke permission from
        :param str permission: Permission to revoke
        :param bool save: Save changes
        :raises: ValueError if user does not have permission
        """
        contributor = user.contributor_set.get(node=self)
        if contributor.has_perm(permission, self):
            permission_to_remove = expand_permissions(permission)
            remove_perm(permission_to_remove, contributor, self)
            contributor.save()
        else:
            raise ValueError('User does not have permission {0}'.format(permission))
        if save:
            self.save()

    def add_contributors(self, contributors, auth=None, log=True, save=False):
        """Add multiple contributors

        :param list contributors: A list of dictionaries of the form:
            {
                'user': <User object>,
                'permissions': <Permissions list, e.g. ['read', 'write']>,
                'visible': <Boolean indicating whether or not user is a bibliographic contributor>
            }
        :param auth: All the auth information including user, API key.
        :param log: Add log to self
        :param save: Save after adding contributor
        """
        for contrib in contributors:
            self.add_contributor(
                contributor=contrib['user'], permissions=contrib['permissions'],
                visible=contrib['visible'], auth=auth, log=False, save=False,
            )
        # todo: implement preprint log
        # if log and contributors:
        #     self.add_log(
        #         action=NodeLog.CONTRIB_ADDED,
        #         params={
        #             'project': self.parent_id,
        #             'node': self._primary_key,
        #             'contributors': [
        #                 contrib['user']._id
        #                 for contrib in contributors
        #             ],
        #         },
        #         auth=auth,
        #         save=False,
        #     )
        if save:
            self.save()

    def add_unregistered_contributor(self, fullname, email, auth, send_email='default',
                                     visible=True, permissions=None, save=False, existing_user=None):
        """Add a non-registered contributor to the project.

        :param str fullname: The full name of the person.
        :param str email: The email address of the person.
        :param Auth auth: Auth object for the user adding the contributor.
        :param User existing_user: the unregister_contributor if it is already created, otherwise None
        :returns: The added contributor
        :raises: DuplicateEmailError if user with given email is already in the database.
        """
        # Create a new user record if you weren't passed an existing user
        contributor = existing_user if existing_user else OSFUser.create_unregistered(fullname=fullname,
                                                                                      email=email)

        contributor.add_unclaimed_record(node=self, referrer=auth.user,
                                         given_name=fullname, email=email)
        try:
            contributor.save()
        except ValidationError:  # User with same email already exists
            contributor = get_user(email=email)
            # Unregistered users may have multiple unclaimed records, so
            # only raise error if user is registered.
            if contributor.is_registered or self.is_contributor(contributor):
                raise

            contributor.add_unclaimed_record(
                node=self, referrer=auth.user, given_name=fullname, email=email
            )

            contributor.save()

        self.add_contributor(
            contributor, permissions=permissions, auth=auth,
            visible=visible, send_email=send_email, log=True, save=False
        )
        self.save()
        return contributor

    def add_contributor_registered_or_not(self, auth, user_id=None,
                                          full_name=None, email=None, send_email='false',
                                          permissions=None, bibliographic=True, index=None, save=False):

        if user_id:
            contributor = OSFUser.load(user_id)
            if not contributor:
                raise ValueError('User with id {} was not found.'.format(user_id))
            if not contributor.is_registered:
                raise ValueError(
                    'Cannot add unconfirmed user {} to node {} by guid. '
                    'Add an unregistered contributor with fullname and email.'.format(user_id, self._id)
                )
            if self.contributor_set.filter(user=contributor).exists():
                raise ValidationValueError('{} is already a contributor.'.format(contributor.fullname))
            contributor, _ = self.add_contributor(contributor=contributor, auth=auth, visible=bibliographic,
                                                  permissions=permissions, send_email=send_email, save=True)
        else:

            try:
                contributor = self.add_unregistered_contributor(
                    fullname=full_name, email=email, auth=auth,
                    send_email=send_email, permissions=permissions,
                    visible=bibliographic, save=True
                )
            except ValidationError:
                contributor = get_user(email=email)
                if self.contributor_set.filter(user=contributor).exists():
                    raise ValidationValueError('{} is already a contributor.'.format(contributor.fullname))
                self.add_contributor(contributor=contributor, auth=auth, visible=bibliographic,
                                     send_email=send_email, permissions=permissions, save=True)

        auth.user.email_last_sent = timezone.now()
        auth.user.save()

        if index is not None:
            self.move_contributor(contributor=contributor, index=index, auth=auth, save=True)

        contributor_obj = self.contributor_set.get(user=contributor)
        contributor.permission = get_perms(contributor_obj, self)
        contributor.bibliographic = contributor_obj.visible
        contributor.preprint_id = self._id
        contributor_order = list(self.get_contributor_order())
        contributor.index = contributor_order.index(contributor_obj.pk)

        if save:
            contributor.save()

        return contributor_obj

    def set_visible(self, user, visible, log=True, auth=None, save=False):
        if not self.is_contributor(user):
            raise ValueError(u'User {0} not in contributors'.format(user))
        if visible and not PreprintContributor.objects.filter(preprintservice=self, user=user, visible=True).exists():
            PreprintContributor.objects.filter(preprintservice=self, user=user, visible=False).update(visible=True)
        elif not visible and PreprintContributor.objects.filter(preprintservice=self, user=user, visible=True).exists():
            if PreprintContributor.objects.filter(preprintservice=self, visible=True).count() == 1:
                raise ValueError('Must have at least one visible contributor')
            PreprintContributor.objects.filter(preprintservice=self, user=user, visible=True).update(visible=False)
        else:
            return

        # todo: implement preprint log
        # message = (
        #     NodeLog.MADE_CONTRIBUTOR_VISIBLE
        #     if visible
        #     else NodeLog.MADE_CONTRIBUTOR_INVISIBLE
        # )
        # if log:
        #     self.add_log(
        #         message,
        #         params={
        #             'parent': self.parent_id,
        #             'node': self._id,
        #             'contributors': [user._id],
        #         },
        #         auth=auth,
        #         save=False,
        #     )
        if save:
            self.save()

    def add_contributor(self, contributor, permissions=None, visible=True,
                        send_email='default', auth=None, log=True, save=False):
        """Add a contributor to the project.

        :param User contributor: The contributor to be added
        :param list permissions: Permissions to grant to the contributor
        :param bool visible: Contributor is visible in project dashboard
        :param str send_email: Email preference for notifying added contributor
        :param Auth auth: All the auth information including user, API key
        :param bool log: Add log to self
        :param bool save: Save after adding contributor
        :returns: Whether contributor was added
        """
        MAX_RECENT_LENGTH = 15

        # If user is merged into another account, use master account
        contrib_to_add = contributor.merged_by if contributor.is_merged else contributor
        if contrib_to_add.is_disabled:
            raise ValidationValueError('Deactivated users cannot be added as contributors.')

        if not self.is_contributor(contrib_to_add):

            contributor_obj, created = PreprintContributor.objects.get_or_create(user=contrib_to_add, node=self)
            contributor_obj.visible = visible

            # Add default contributor permissions
            permissions = permissions or DEFAULT_CONTRIBUTOR_PERMISSIONS
            assign_perm(permissions, contributor_obj, self)
            contributor_obj.save()

            # Add contributor to recently added list for user
            if auth is not None:
                user = auth.user
                recently_added_contributor_obj, created = RecentlyAddedContributor.objects.get_or_create(
                    user=user,
                    contributor=contrib_to_add
                )
                recently_added_contributor_obj.date_added = timezone.now()
                recently_added_contributor_obj.save()
                count = user.recently_added.count()
                if count > MAX_RECENT_LENGTH:
                    difference = count - MAX_RECENT_LENGTH
                    for each in user.recentlyaddedcontributor_set.order_by('date_added')[:difference]:
                        each.delete()

            # todo: implement preprint log
            # if log:
            #     self.add_log(
            #         action=NodeLog.CONTRIB_ADDED,
            #         params={
            #             'project': self.parent_id,
            #             'node': self._primary_key,
            #             'contributors': [contrib_to_add._primary_key],
            #         },
            #         auth=auth,
            #         save=False,
            #     )
            if save:
                self.save()

            if self._id:
                project_signals.contributor_added.send(self,
                                                       contributor=contributor,
                                                       auth=auth, email_template=send_email)
            self.update_search()
            self.save_node_preprints()
            return contrib_to_add, True

        # Permissions must be overridden if changed when contributor is
        # added to parent he/she is already on a child of.
        elif self.is_contributor(contrib_to_add) and permissions is not None:
            self.set_permissions(contrib_to_add, permissions)
            if save:
                self.save()

            return False
        else:
            return False
