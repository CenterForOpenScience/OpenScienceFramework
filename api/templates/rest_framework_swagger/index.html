{% extends 'rest_framework_swagger/base.html' %}
{% load staticfiles %}

{% block style %}
    <link href="//fonts.googleapis.com/css?family=Droid+Sans:400,700" rel="stylesheet" type="text/css"/>
    <link href="{% static 'rest_framework_swagger/css/highlight.default.css' %}" media="screen" rel="stylesheet" type="text/css"/>
    <link href="{% static 'rest_framework_swagger/css/atelier-dune.light.css' %}" media="screen" rel="stylesheet" type="text/css"/>
    <link href="{% static 'rest_framework_swagger/css/osf_rest_framework_swagger.css' %}" media="screen" rel="stylesheet" type="text/css"/>
    <link href="{% static 'rest_framework_swagger/css/osf_screen.css' %}" media="screen" rel="stylesheet" type="text/css"/>
{% endblock %}

{% block branding %}
    <a id="logo" href="http://osf.io">
        <img class="osf-logo" src="{% static 'rest_framework_swagger/images/cos-white2.png' %}" width="27">
        OSF
    </a>
{% endblock %}
{% block api_selector %}
    <form id="api_selector">
        <div class="input"><input placeholder="http://example.com/api" id="input_baseUrl" name="baseUrl" type="text"/></div>
        <div class="input"><input placeholder="api_key" id="input_apiKey" name="apiKey" type="text"/></div>
        <div class="input"><a id="explore" href="#">Explore</a></div>
    </form>
{% endblock %}

{% block swagger_patches %}
<script>

// TODO 
// Move this patch to an external file somehow.


// Here we modify the SwaggerRequest constructor in 
// such a way as to decorate the response callback that gets passed to it
// when it is used to make a request to the api.
// The decoration has access to the dom element which the response updates, 
// and to the response data.
(function() {

    // We take a reference the SwaggerRequest constructor
    var SwaggerRequest__unpatched = SwaggerRequest;
    // And create a new wrapper around it assigned to the original name.
    SwaggerRequest = function(type, url, params, opts, successCallback, errorCallback, operation, execution) {
       
        // We take a reference to the callback that is passed to the constructor 
        var successCallback__unpatched = successCallback;
        // And put a wrapper around it.
        successCallback = function(response, opts_parent) {
            
            // We need our code to fire after the original callback has finished.
            // It's synchronous, so we can just take the return value here.
            var ret = successCallback__unpatched(response, opts_parent);
            
            // We need to do a reverse lookup for the url we want to navigate to.
            // Let's build a set of regexes that will match urls that are
            // associated with that given endpoint.
            const ops = operation.resource.operationsArray.map(function(op) {
            
                var re = op.path;

                // This is a workaround for a bug? maybe... 
                // one of the paths has a random parenthese in it.. 
                // Will open a ticket if I cant figure it out
                // before this PR is submitted.
                re = re.replace(/\x29/g, ""); // ???
                
                // Urls that contain paths have a "virtual" forward-slash in them
                // Swagger doesn't see if because the route regex captures it.
                re = re.replace(/{path}/g, ""); // ???

                // Create a pattern from the path that will match valid values.
                // of variable data.
                re = re.replace(/{(?:[a-z_])+}/g, "([0-9a-zA-Z]+)");
                
                // Turn it into a regular expression.
                re = re.replace(/\//g, "\\/");
                op.re = new RegExp(re);
                
                return op;     
            
            });
            // The dom has been updated with the response from 
            // swagger's api request now, so we can mess around with 
            // the links in the response. All links exist in strings, and
            // conveniently, hljs has put them all in `.hljs-string` classed
            // span tags! 
            var json_strings = opts_parent.el.querySelectorAll('.response_body .hljs-string');
            var urls = Array.prototype.filter.call(json_strings, function(url_el) {
               
                // It's a pretty fair assumption that if a string starts with 
                // one of these it's probably a link. (This is actually how 
                // Swagger looks for urls.)
                return (
                    url_el.innerHTML.slice(1, 5) == "http" ||
                    url_el.innerHTML.slice(1, 6) == "https"
                ); 
            
            }).map(function(url_el) {
                
                // Now we have an array of all the links (or the span tags that
                // contain them, anyway) that were 
                // in the response; we can do something cool with them.
                
                // It's JSON, so strings have quotes around them.
                var url = url_el.innerHTML.slice(1, -1);
            
                // We're gonna want an anchor anyway, but anchors have cool
                // url 'parsing' properties, so we're gonna use them.
                // This is consistent across all modern browsers. IE9 and earlier
                // doesn't like it though.
                var anchor = document.createElement('a');
                anchor.href = url;
                anchor.textContent = url;
                var pn = anchor.pathname;
                
                // For those links that are associated with an operation
                // in the api...

                if (ops.map(function(op) {                    
                    
                    // ...execute the regex associated with this operation on the 
                    // api endpoint we're checking right now...
                    op.matched = op.re.exec(pn);
                    return op;               
 
                }).filter(function(op, i, ops) {
                    // ...to see we have a operation that takes a path that looks like this.
                    return (
                        op.matched && // ENsure there is a match.
                        op.matched[0] == pn // ENsure we match the whole thing.
                    );

                }).map(function(op) {


                    // Lets populate our link There's too much formatting here to make 
                    // dom methods reasonable; string concatenation is more readable.
                    var target_op_el = document.getElementById(op.parentId + "_" + op.nickname);
                    
                    url_el.innerHTML = "\"<a href=\"#" + target_op_el.id + "\">" + url +" </a>\"";
                    // Create a link to the raw JSON 
                    
                    
                    var params = document.querySelectorAll("#" + target_op_el.id + " div.content .sandbox .parameter.required");
                    Array.prototype.map.call(params, function(param, i) {
                        // Elements of the `matched` array (the result of `[[RegEx]].exec([[string]])`) are captured arguments.
                        param.value = op.matched[i+1]; 
                    });

                    // If it's not a get request, we're done.
                    // Some guards to make sure we only attach an event to the get 
                    // request(avoids deleting files and the like)
                    if (!target_op_el) return; // Sanity
                    if (op.method !== 'get') return; // Only `GET`s
                    var this_host = op.resource.basePath;
                    if (anchor.protocol + "//" + anchor.host !== this_host) return; // Has to be an api request/
                    url_el.innerHTML += " <span class='hljs-comment'>/* <a target=\"_blank\" href=\""+url+"?format=json\">raw_json</a> */</span>";


                    // It's a `GET`; make it show us what we want to see when we click it.
                    url_el.addEventListener("click", function(e) {
                        
                        document.querySelector("#" + target_op_el.id + " div.content .sandbox_header .submit").click();
                        animate(function(y) {
                            window.scrollTo(0, y)
                        }, window.scrollY, target_op_el.offsetTop, .3, null, function() { 
                            
                            // update the location bar and show the content of this operation.
                            document.querySelector("#" + target_op_el.id + " .heading a").click(); 
                            window.location.hash = "!/v2/" + op.nickname; // This may break when we update swagger.
                            var op_content = document.querySelector("#" + target_op_el.id + " div.content");
                            $(op_content).slideDown() // Ew.
                            
                            // Once we're at the operation, scroll to the response section.
                            var to_v_sbox = document.querySelector("#" + target_op_el.id + ' div.content .response-content-type')
                            animate(function(y) {
                                window.scrollTo(0, y)
                            }, window.scrollY, to_v_sbox.offsetTop, .3, null, function() {});
                            
                        });
                        
                    });
               
                // If there were no operations that matched. 
                }).length <= 0) url_el.innerHTML = "<a target=\"_blank\" href=\""+url+"\">"+url+"</a>";
            
            })
            return ret;
        
        }
       
        // `new` gets called on out new constuctor that we're creating here, 
        // so we're getting a new `this` which we can use on our constructor.
        // without having to create another new object or even return anything...  
        SwaggerRequest__unpatched.bind(this)(type, url, params, opts, successCallback, errorCallback, operation, execution);
    
    }
    
    // //////////////////////////////////////////////////////////////////////// 
    // Define functions used in the patch

    const pi = 3.14159265359;
    
    
    function cubicInOut(x) { 
        return -2 * Math.pow(x, 3) + 3 * Math.pow(x, 2); 
    }
    
    // Basically cos^n when n is even gives a 
    // nice `accelarate, coast, brake;` function over each 
    // period, so the integral describes how far we've gone. 
    function cosPow6Intg(x) {
        return x - ((15*Math.sin(2*pi*x))/(44*pi)) - ((3*Math.sin(4*pi*x))/(44*pi)) - ((Math.sin(6*pi*x))/(132*pi));
    }
    
    // Make our transition nice'n'smooth
    function animate(propertySetter, start, end, speed, units, animationCompletedCallback) {
    
        units = units || 0;
        propertySetter(start + units);

        // Should be in all modern browsers now.
        // We could run a check and if need be use `Date.now()`.
        var start_time = performance.now(); 
        var change = end - start;
        var duration = Math.abs(change*speed)+1000;
        
        (function step() {
            var time_now = performance.now();
            var elapsed_time = time_now - start_time;
            requestAnimationFrame(function(ts) { // requestAnimationFrame() === Butter.
                propertySetter(start + change * cosPow6Intg(elapsed_time/duration) + units);
                if (elapsed_time >= duration) {
                    propertySetter(end + units);
                    animationCompletedCallback();
                    return;
                }
                step();
            });
        })();

    }
    
})();
</script>
{% endblock %}

