'use strict';
var $ = require('jquery');
var m = require('mithril');
var $osf = require('js/osfHelpers');
var utils = require('js/share/utils');

var widgetUtils = {};

widgetUtils.timeSinceEpochInMsToMMYY = function(timeSinceEpochInMs) {
    var d = new Date(timeSinceEpochInMs);
    return (d.getDate()+1).toString() + '/' + (d.getMonth()+1).toString() + '/' + d.getFullYear().toString().substring(2);
};

/**
 * Checks if an update has been requested for this widget
 *
 * @param {string} name of widget to check
 * @vm {object} searchDashboard vm containing a list of widgets that need to be updated (vm.widgetsToUpdate)
 * @return {bool}  returns itself
 */
widgetUtils.updateTriggered = function(widgetName, vm){
    if (vm.widgetsToUpdate.indexOf(widgetName) === -1){
        return false;
    }
    vm.widgetsToUpdate.splice($.inArray(widgetName, vm.widgetsToUpdate), 1); //signal that this widget has been redrawn
    return true;
};

/**
 * Adds the widget to the list of widgets that need to be updated (will actually update at next redraw)
 *
 * @param {object} searchDashboard vm containing a list of widgets that need to be updated (vm.widgetsToUpdate)
 * @param {string} list of widgets that need to be added to the list of widgets to update
 * @return {bool}  returns itself
 */
widgetUtils.signalWidgetsToUpdate = function(vm, widgetsToAdd){
    vm.widgetsToUpdate = widgetUtils.concatUnique(vm.widgetsToUpdate, widgetsToAdd);
};

/**
 * Concatenates too arrays and removes non-unique values
 *
 * @param {array} array to add to
 * @param {array} array to add
 * @return {bool}  concatenation of the unique values of the two arrays
 */
widgetUtils.concatUnique = function(array1, array2){
     var temp = array1.concat(array2);
     return temp.filter(function(item, i, arr){ return arr.indexOf(item) === i; }); //make unique so we dont redraw widgets more than we have to
};

widgetUtils.mapGuidsToName = function(guids){
    var guidFilters = [];
    var newGuidMaps = {};
    for(var guid in guids){
        guidFilters.push('match:id:' + guids[guid]);
    }
    var tempvm = {};
    tempvm.query = m.prop('*');
    tempvm.optionalFilters = guidFilters;
    tempvm.requiredFilters = ['match:category:user'];
    tempvm.size = guids.length;
    utils.buildQuery(tempvm);
    return m.request({
        method: 'post',
        background: true,
        data: utils.buildQuery(tempvm),
        url: '/api/v1/search/'
    }).then(function (data) {
        data.results.forEach(function(user){
            newGuidMaps[user.id] = user.user;
        });
        return newGuidMaps;
    }, function (xhr, status, err) {
        $osf.growl('Error','could not load names of collaborators','danger');
    });
};

widgetUtils.keysNotInObject = function(keys, object){
    return $.map(keys, (function(key){
        if (object[key] === undefined){
            return key;
        }
    }));
};

widgetUtils.getObjectById = function(listOfObjects,id){
    var obIndex = $.map(listOfObjects, function(obj, index) {
        if (obj.levelNames[0] === id) {
            return index;
        }
    });
    return listOfObjects[obIndex];
};

widgetUtils.getKeyFromValue = function(object,value){
  for(var key in object){
    if(object[key] === value){
      return key;
    }
  }
  return null;
};

widgetUtils.getGuidsToNamesMap = function(urls, widget, vm) {
    var missingKeys = widgetUtils.keysNotInObject(urls, vm.tempData.guidsToNames); //check if we have the names for these urls

    if (missingKeys.length > 0) { //if we have missing keys then we have to add to the map between url and name
        widget.display.dataReady(false);
        if (vm.requestFlags.nameRequest) { //a request has already been scheduled...
            return false;
        }
        vm.requestFlags.nameRequest = true; //flag that we are requesting data
        widgetUtils.mapGuidsToName(missingKeys).then(
            function (newGuids) {
                vm.requestFlags.nameRequest = false; //flag that this request has finished
                $.extend(vm.tempData.guidsToNames, newGuids);
                widget.display.dataReady(true); //TODO move widget out of here somehow, its too coupled
                m.redraw(); //cool, now we have the data we need, so lets try creating this chart again...
                //note that other charts will not update because we haven't signaled there update
            }
        );
        return false;
    }
    return vm.tempData.guidsToNames;
};

module.exports = widgetUtils;
