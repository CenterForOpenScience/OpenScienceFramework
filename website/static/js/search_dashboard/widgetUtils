'use strict';
var $ = require('jquery');
var m = require('mithril');
var $osf = require('js/osfHelpers');
var utils = require('js/share/utils');

var widgetUtils = {};

/**
 * Return time since epoch (ms) in human readable format
 *
 * @param {string} timeSinceEpochInMs: the time since epoch in ms
 * @return {string} human readable date
 */
widgetUtils.timeSinceEpochInMsToMMYY = function(timeSinceEpochInMs) {
    var d = new Date(timeSinceEpochInMs);
    return (d.getDate()+1).toString() + '/' + (d.getMonth()+1).toString() + '/' + d.getFullYear().toString().substring(2);
};

/**
 * Checks if an update has been requested for this widget. THIS IS NOT A PURE FUNCTION: vm.widgetsToUpdate is modified
 *
 * @param {string} widgetName: name of widget to check
 * @param {object} vm: searchDashboard vm containing a list of widgets that need to be updated (vm.widgetsToUpdate)
 * @return {bool}  returns true if it has, false if not.
 */
widgetUtils.updateTriggered = function(widgetName, vm){
    if (vm.widgetsToUpdate.indexOf(widgetName) === -1){
        return false;
    }
    vm.widgetsToUpdate.splice($.inArray(widgetName, vm.widgetsToUpdate), 1); //signal that this widget has been redrawn
    return true;
};

/**
 * Adds the widget to the list of widgets that need to be updated (will actually update at next redraw)
 *
 * @param {Object} vm: searchDashboard vm containing a list of widgets that need to be updated (vm.widgetsToUpdate)
 * @param {Array} widgetsToAdd: list of widgets that need to be added to the list of widgets to update
 * @return {Bool}  returns itself
 */
widgetUtils.signalWidgetsToUpdate = function(vm, widgetsToAdd){
    if ($.inArray('all', widgetsToAdd) > -1){
        vm.widgetsToUpdate = widgetUtils.concatUnique(vm.widgetsToUpdate, vm.widgetIds);
    }
    vm.widgetsToUpdate = widgetUtils.concatUnique(vm.widgetsToUpdate, widgetsToAdd);
};

/**
 * Concatenates too arrays and removes non-unique values
 *
 * @param {Array} array1: array to add to
 * @param {Array} array2: array to add
 * @return {Bool}  concatenation of the unique values of the two arrays
 */
widgetUtils.concatUnique = function(array1, array2){
     var temp = array1.concat(array2);
     return temp.filter(function(item, i, arr){ return arr.indexOf(item) === i; }); //make unique so we dont redraw widgets more than we have to
};

/**
 * requests user information for guid's supplied, then builds map from guids to name, returns map.
 * TODO: this could be made more generic, to just return user information which can then be processed in another function
 *
 * @param {array} guids: an array of guid's to request user information from
 * @return {bool}  map of guids to name
 */
widgetUtils.nameRequest = function(guids){
    var guidFilters = [];
    var newGuidMaps = {};
    $.map(guids, function(guid){
        guidFilters.push('match:id:' + guid);
    });
    var guidQuery = {};
    guidQuery.query = m.prop('*');
    guidQuery.optionalFilters = guidFilters;
    guidQuery.requiredFilters = ['match:category:user'];
    guidQuery.size = guids.length;
    return m.request({
        method: 'post',
        background: true,
        data: utils.buildQuery(guidQuery),
        url: '/api/v1/search/'
    }).then(function (data) {
        data.results.forEach(function(user){
            newGuidMaps[user.id] = user.user;
        });
        return newGuidMaps;
    }, function (xhr, status, err) {
        $osf.growl('Error','could not load names of collaborators','danger');
    });
};

/**
 * Finds and returns the keys not present in an object.
 *
 * @param {array} keys: an array of keys to check against
 * @param {object} object: The object to search through
 * @return {array}  Missing keys from object, returns [] if nothing missing
 */
widgetUtils.keysNotInObject = function(keys, object){
    return $.map(keys, (function(key){
        if (object[key] === undefined){
            return key;
        }
    }));
};

/**
 * finds and returns and object from a list of objects whose id matches the given id.
 *
 * @param {array} listOfObjects: A array containing a set of objects to match the ide feild with
 * @param {string} id: The id to match
 * @return {Object}  matched object
 */
widgetUtils.getObjectById = function(listOfObjects,id){
    var obIndex = $.map(listOfObjects, function(obj, index) {
        if (obj.id === id) {
            return index;
        }
    });
    return listOfObjects[obIndex];
};

/**
 * Get the key of the object whose value matches given value
 *
 * @param {Object} object: Object to search through
 * @param {string/int} value: value to match to
 * @return {Object}  matched object
 */
widgetUtils.getKeyFromValue = function(object,value){
  var key;
  for(key in object){
    if(object[key] === value){
      return key;
    }
  }
  return null;
};

/**
 * Return a map of guids to full names. Or request this information and return false if not available.
 *
 * @param {Array} guids: a list of guids to return name mapping for
 * @param {Object} widget: widget to flag readiness for //TODO remove need for widget, with request flags in vm
 * @param {Object} vm: widget to flag readiness for
 * @return {Object}  an object which whose keys are guids and values are full names
 */
widgetUtils.getGuidsToNamesMap = function(guids, widget, vm) {
    var missingKeys = widgetUtils.keysNotInObject(guids, vm.tempData.guidsToNames); //check if we have the names for these urls

    if (missingKeys.length > 0) { //if we have missing keys then we have to add to the map between url and name
        widget.display.dataReady(false);
        if (vm.requestFlags.nameRequest) { //a request has already been scheduled...
            return false;
        }
        vm.requestFlags.nameRequest = true; //flag that we are requesting data
        widgetUtils.nameRequest(missingKeys).then(
            function (newGuids) {
                vm.requestFlags.nameRequest = false; //flag that this request has finished
                $.extend(vm.tempData.guidsToNames, newGuids);
                widget.display.dataReady(true); //TODO move widget out of here somehow, its too coupled
                m.redraw(); //cool, now we have the data we need, so lets try creating this chart again...
                //note that other charts will not update because we haven't signaled there update
            }
        );
        return false;
    }
    return vm.tempData.guidsToNames;
};


widgetUtils.missingRequests(vm, widget){
    
    widget.thisWidgetRequiresRequests.forEach(function(reqRequest){
        if reqRequest in
    });
}

/**
//TODO
 */
widgetUtils.buildRequest = function(id, request, aggs){
    var req =  {
        id : id,
        elasticURL: request.elasticURL,
        query: request.query || m.prop('*'),
        optionalFilters : request.optionalFilters || [],
        requiredFilters : request.requiredFilters || [],
        aggregations : aggs || [],
        data: null,
        complete: false,
        sort: m.prop(request.sort || 'Relevance')
    };
    utils.search(req);
    return req;
};

module.exports = widgetUtils;
